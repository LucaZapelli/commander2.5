####
#### COMMANDER 2.1 >> Implementing frequency correlated noise
####
---- PATCH LOG:
-------- 1. Each processor handles a single main band, although importing every noise covariance 
--------    and computing residual/signal maps for all bands when a N^-1 d operation has to be 
--------    performed. Other quantities are expanded to every band, such as beams, foreground
--------    spectral responses and templates.
-------- 2. Ft N^-1 F computation is simplified, limiting the Ft N^-1 F solving to a vector-scalar
--------    product rather then a matrix-vector one.
-------- 3. Chi^2 computation formula has been changed, replacing the sqrt{N^-1} multiplica-
--------    tion with the standard N^-1 one. The reason is that the new routine treats 
--------    differently the rhs e and the lhs map terms, so that the multiplication of the two
--------    no longer equals lhs^2.


##########################################################################################################################################
##########################################################################################################################################

List of ADDED/MODDED (A/M) lines

*************************
***** commander.f90 *****
*************************
#####################################################
###### DEFINE VARIABLES AND SET WORKING GROUPS ######
#####################################################

M>  integer(i4b)        :: i, j, k, l, m, s, lmax_sht, nside_sht, nmaps_sht, band_iter


################################
###### INITIALIZE MODULES ######
################################

!! Modules initialization:
M>  call initialize_bp_mod(myid, chain, comm_chain, paramfile, rng_handle, freq_corr_noise)
    >> FROM "comm_bp_mod.f90"
          A>  logical(lgt) :: freq_corr_noise
          .>  ...
          .>  subroutine initialize_bp_mod(myid, chain, comm_chain, paramfile, handle)
          .>    ...
          A>    call get_parameter(paramfile, 'FREQ_CORR_NOISE',        par_lgt=freq_corr_noise)
          .>  end subroutine initialize_bp_mod
          
    >> "comm_fg_mod.f90" IMPORTS FROM "comm_{bp/N_mult}_mod.f90"
    >> "comm_Cl_util_mod.f90" DOESN'T USE NEW VARIABLES
    >> "comm_Cl_sampling_mod.f90" IMPORTS FROM "comm_Cl_util_mod.f90"
    >> FROM "comm_beam_mod.f90"
          A>  real(dp),      allocatable, dimension(:,:,:)  :: beams_fcn
          A>  integer(i4b), private :: numband
          A>  logical(lgt), private :: freq_corr_noise
          .>  ...
          .>  subroutine initialize_beam_mod(paramfile, comm_alms_in, comm_chain_in, map_id)
          M>    integer(i4b)       :: unit, band_iter
          .>    ...
          A>    call get_parameter(paramfile, 'NUMBAND',                 par_int=numband)
          A>    call get_parameter(paramfile, 'FREQ_CORR_NOISE',         par_lgt=freq_corr_noise)
          .>    ...
       **** ADDED PROCEDURE ****
          *>    ! Read pixel window function
          *>    allocate(pixwin(0:lmax,1:nmaps))
          *>    call read_beam(pixwinfile, pixwin)
          *>
          *>
          *>    if (.not. freq_corr_noise) then
          *>       call int2string(map_id, map_text)
          *>       paramtext = 'BEAM' // map_text
          *>       call get_parameter(paramfile, trim(paramtext), par_string=beamfile)
          *>
          *>       ! Read beam transfer function; needed even for effective beam for preconditioning
          *>       allocate(beam(0:lmax, nmaps))
          *>       call read_beam(beamfile, beam)
          *>       
          *>       ! Merge pixel and beam windows into one quantity
          *>       beam = beam * pixwin(0:lmax,1:nmaps)
          *>    else
          *>       allocate(beams_fcn(numband, 0:lmax, nmaps))
          *>       allocate(beam(0:lmax, nmaps))
          *>       do band_iter = 1, numband
          *>          call int2string(band_iter, map_text)
          *>          paramtext = 'BEAM' // map_text
          *>          call get_parameter(paramfile, trim(paramtext), par_string=beamfile)
          *>
          *>          ! Read beam transfer function; needed even for effective beam for preconditioning
          *>          call read_beam(beamfile, beam)
          *>    
          *>          ! Merge pixel and beam windows into one quantity
          *>          beam = beam * pixwin(0:lmax,1:nmaps)
          *>       
          *>          beams_fcn(band_iter,:,:) = beam
          *>       end do
          *>    end if
          *>
          *>    ! Read low-resolution beam transfer function
          *>    allocate(beam_lowres(0:lmax_lowres, nmaps))
          *>    !call gaussbeam(fwhm_lowres, lmax_lowres, beam_lowres) ! Setting lowres from low-ls
          *>    if (lmax_lowres <= lmax) then
          *>       beam_lowres = beam(0:lmax_lowres, 1:nmaps)
          *>    end if
          *>
          *>    ! Merge pixel and beam windows into one quantity
          *>    !call read_pixwin(nside, nmaps, pixwin)
          *>    beam_lowres = beam_lowres * pixwin(0:lmax_lowres,1:nmaps)
          *>    deallocate(pixwin)
          *>
          .>  ...
          .>  end subroutine initialize_beam_mod
          
    >> FROM "comm_N_mult_mod.f90"
          M>  integer(i4b),                              private :: comm_chain, myid_chain, map_id, map2_id, map_id_fcn
          A>  character(len=128),                            private :: paramfile, maskfile
          A>  logical(lgt), private :: freq_corr_noise, sample_inside_mask
          .>  ...
          M>  subroutine initialize_N_mult_mod(paramfile_, comm_alms_in, comm_chain_in, map_id_in)    
          M>    character(len=128), intent(in) :: paramfile_
          M>    logical(lgt)       :: polarization
          M>    character(len=2)   :: map_text, map2_text, i_text
          M>    character(len=128) :: noisefile, paramtext
          .>    ...
          A>    paramfile = paramfile_
          .>    ...
          A>    call get_parameter(paramfile, 'FREQ_CORR_NOISE',    par_lgt=freq_corr_noise)
          A>    if (freq_corr_noise) then
          A>       call int2string(map_id, map2_text)
          A>    end if
          .>    ...
          A>    if (freq_corr_noise) then
          A>       paramtext = 'NOISE_RMS' // map_text // map2_text
          A>    else
          M>       paramtext = 'NOISE_RMS' // map_text
          A>    end if
          .>    ...
          A>       if (freq_corr_noise) then
          A>          paramtext = 'INV_N_MAT' // trim(map_text) // trim(map2_text)
          A>       else
          M>          paramtext = 'INV_N_MAT' // map_text
          A>       end if
          A>       if (freq_corr_noise) then
          A>          paramtext = 'SQRT_INV_N_MAT' // trim(map_text) // trim(map2_text)
          A>       else
          M>          paramtext = 'SQRT_INV_N_MAT' // map_text
          A>       end if
          .>  end subroutine initialize_N_mult_mod
          .>  ...
       **** ADDED SUBROUTINE ****
          *>  subroutine initialize_invN_rms_fcn(band_id_in)
          *>    implicit none
          *>    integer(i4b), intent(in)           :: band_id_in
          *>    
          *>    integer(i4b)       :: i, j
          *>    real(dp)           :: reg_noise, reg_scale
          *>    character(len=2)   :: map_text
          *>    character(len=128) :: noisefile, paramtext
          *>    real(dp),     allocatable, dimension(:,:) :: noisemap, mask
          *>
          *>    call int2string(band_id_in, map_text)
          *>
          *>    call get_parameter(paramfile, 'REGULARIZATION_NOISE',      par_dp=reg_noise) 
          *>    call get_parameter(paramfile, 'REG_NOISE_SCALE'//map_text, par_dp=reg_scale)
          *>    reg_noise = reg_noise * reg_scale
          *>
          *>    map_id_fcn = band_id_in
          *>
          *>    allocate(mask(0:npix-1,nmaps))
          *>    call read_map(maskfile, mask)
          *>
          *>    paramtext = 'NOISE_RMS' // map_text
          *>    call get_parameter(paramfile, trim(paramtext), par_string=noisefile)
          *>
          *>    allocate(noisemap(0:npix-1,nmaps))
          *>    call read_map(noisefile, noisemap)
          *>    if (reg_noise > 0.d0) then
          *>       noisemap = reg_noise
          *>    else if (reg_noise < 0.d0) then
          *>       noisemap = sqrt(noisemap**2 + reg_noise**2)
          *>    end if       
          *>
          *>    invN_rms = 0.d0
          *>    do j = 1, nmaps
          *>       do i = 0, map_size-1
          *>          if (mask(pixels(i),j) == 1.d0) then
          *>             invN_rms(i,j,OUTSIDE_MASK) = 1.d0 / noisemap(pixels(i),j)**2
          *>          else if (sample_inside_mask) then
          *>             invN_rms(i,j,INSIDE_MASK)  = 1.d0 / noisemap(pixels(i),j)**2
          *>          end if
          *>       end do
          *>       if (all(mask(:,j) == 0.d0)) invN_rms(:,j,:) = 0.d0
          *>    end do
          *>    sqrt_invN_rms = sqrt(invN_rms)
          *>    deallocate(noisemap)
          *>  subroutine initialize_invN_rms_fcn
          .>  ...
          M>  subroutine get_noise_map(mask_state, inv_N, band_id_in) 
          A>    integer(i4b),                   intent(in),  optional :: band_id_in 
          .>    ...
          A>    if (freq_corr_noise .and. present(band_id_in)) then
          A>       if (present(inv_N)) inv_N = map2 / noiseamp(band_id_in)**2
          A>    else if (.not. freq_corr_noise) then
          M>       if (present(inv_N)) inv_N = map2 / noiseamp(map_id)**2
          A>    end if   
          .>  end subroutine get_noise_map
          
    >> "comm_data_mod.f90" IMPORTS FROM "comm_{N_mult/beam}_mod.f90"
          A>  real(dp), allocatable, dimension(:),    private :: reg_noises_fcn
          A>  real(dp),     allocatable, dimension(:,:,:)     :: cmbmaps_fcn, residuals_fcn
          A>  real(dp),     allocatable, dimension(:,:,:)     :: mask_calibs_fcn
          A>  real(dp),     allocatable, dimension(:,:,:,:)   :: fg_pix_spec_responses_fcn
          A>  real(dp),     allocatable, dimension(:,:,:,:)   :: fg_temps_fcn
          A>  real(dp),     allocatable, dimension(:,:,:,:)   :: inv_Ns_lowres_fcn, inv_Ns_scaled_fcn
          .>  ...
          .>  subroutine initialize_data_mod(...)
          M>    integer(i4b)       :: ordering, temp_i, num_md_temp, i, j, k, l, ierr, ind, band_iter
          M>    character(len=2)   :: map_text, map2_text, temp_text
          A>    character(len=128), allocatable, dimension(:,:)   :: temp_names_fcn
          .>    ...
       **** ADDED PROCEDURE ****
          *>       if (.not. freq_corr_noise) then
          *>          if (sample_fg_temp) then
          *>             allocate(temp_names(num_fg_temp))
          *>
          *>             ! Read foreground template filenames
          *>             do j = 1, num_fg_temp
          *>                call int2string(j,temp_text)
          *>                paramtext = 'FG_TEMPLATE' // map_text // '_' // temp_text
          *>                call get_parameter(paramfile, trim(paramtext), &
          *>                     & par_string=temp_names(j))
          *>             end do
          *>          else
          *>             num_fg_temp = 0
          *>          end if
          *>       else
          *>          allocate(reg_noises_fcn(numband))
          *>          if (sample_fg_temp) allocate(temp_names_fcn(numband, num_fg_temp))
          *>
          *>          do band_iter = 1, numband
          *>             call int2string(band_iter, map_text)
          *>             call get_parameter(paramfile, 'REG_NOISE_SCALE'//map_text, par_dp=reg_scale)
          *>             reg_noises_fcn(band_iter) = reg_noise * reg_scale
          *>
          *>             if (sample_fg_temp) then
          *>                ! Read foreground template filenames
          *>               do j = 1, num_fg_temp
          *>                   call int2string(j,temp_text)
          *>                   paramtext = 'FG_TEMPLATE' // map_text // '_' // temp_text
          *>                   call get_parameter(paramfile, trim(paramtext), &
          *>                        & par_string=temp_names_fcn(band_iter,j))
          *>                end do
          *>            else
          *>                num_fg_temp = 0
          *>             end if
          *>          end do
          *>       end if
          .>    ...
          A>    call mpi_bcast(freq_corr_noise,     1,   MPI_LOGICAL,   root, comm_alms, ierr) 
          A>    if (freq_corr_noise) then
          A>       allocate(cmbmaps_fcn(numband, 0:map_size-1, nmaps))
          A>       allocate(residuals_fcn(numband, 0:map_size-1, nmaps))
          A>       !allocate(foreground_map(0:map_size-1, nmaps))
          A>       allocate(mask_calibs_fcn(numband, 0:map_size-1, nmaps))
          A>    end if
          .>    ...
          A>    deallocate(mask_in)            
          .>    ...
       **** ADDED PROCEDURE ****
          *>    if (freq_corr_noise) then
          *>       do band_iter = 1, numband
          *>          call int2string(band_iter, map_text)
          *>          call get_parameter(paramfile, 'MASKFILE_CALIB'//map_text,  par_string=maskfile_calib)
          *>          call read_map(maskfile_calib, map_in)
          *>          mask_calibs_fcn(band_iter,:,:) = map_in(pixels,:)
          *>          where (mask_calibs_fcn(:,:,band_iter) > 0.5d0)
          *>             mask_calibs_fcn(band_iter,:,:) = 1.d0
          *>          elsewhere
          *>             mask_calibs_fcn(band_iter,:,:) = 0.d0
          *>          end where
          *>       end do
          *>    end if
          *>    deallocate(map_in)
          .>    ...
       **** ADDED PROCEDURE ****
          *>    ! Initialize templates
          *>    if (num_fg_temp > 0) then
          *>       if (.not. freq_corr_noise) then
          *>          allocate(fg_temp(0:map_size-1,nmaps,num_fg_temp))
          *>   
          *>          fg_temp = 0.d0
          *>          if (sample_T_modes) then
          *>             call initialize_mono_and_dipole_temp(nside, fg_temp(:,1,1:4), pixels)
          *>          end if
          *>   
          *>          if (sample_fg_temp) then
          *>             allocate(foreground_map_in(0:npix-1,nmaps))
          *>             
          *>             if (myid_alms == root) then
          *>                   
          *>                do j = 1, num_fg_temp-num_md_temp
          *>                   call read_map(temp_names(j), foreground_map_in)
          *>                   if (nmaps==3 .and. (.not. sample_T_modes)) foreground_map_in(:,1) = 0.d0
          *>                   call mpi_bcast(foreground_map_in, size(foreground_map_in), &
          *>                        & MPI_DOUBLE_PRECISION, root, comm_alms, ierr)
          *>                   fg_temp(:,:,num_md_temp+j) = foreground_map_in(pixels,:)
          *>                end do
          *>                
          *>                deallocate(temp_names)
          *>                
          *>             else
          *>                
          *>                do j = 1, num_fg_temp-num_md_temp
          *>                   call mpi_bcast(foreground_map_in, size(foreground_map_in), &
          *>                        & MPI_DOUBLE_PRECISION, root, comm_alms, ierr)
          *>                   fg_temp(:,:,num_md_temp+j) = foreground_map_in(pixels,:)
          *>                end do
          *>                
          *>             end if
          *>             deallocate(foreground_map_in)
          *>   
          *>             if (polarization .and. (.not. sample_T_modes)) fg_temp(:,1,:) = 0.d0
          *>   
          *>          end if
          *>
          *>       else
          *>          allocate(fg_temps_fcn(numband,0:map_size-1,nmaps,num_fg_temp))
          *>   
          *>          fg_temps_fcn = 0.d0
          *>          if (sample_T_modes) then
          *>             do band_iter = 1, numband
          *>                call initialize_mono_and_dipole_temp(nside, fg_temps_fcn(band_iter,:,1,1:4), pixels)
          *>             end do
          *>          end if
          *>   
          *>          if (sample_fg_temp) then
          *>             allocate(foreground_map_in(0:npix-1,nmaps))
          *>             
          *>             if (myid_alms == root) then
          *>                do j = 1, num_fg_temp-num_md_temp
          *>                   do band_iter = 1, numband
          *>                      call read_map(temp_names_fcn(band_iter,j), foreground_map_in)
          *>                      if (nmaps==3 .and. (.not. sample_T_modes)) foreground_map_in(:,1) = 0.d0
          *>                      if (band_iter == map_id) then
          *>                         call mpi_bcast(foreground_map_in, size(foreground_map_in), &
          *>                              & MPI_DOUBLE_PRECISION, root, comm_alms, ierr)
          *>                      end if
          *>                      fg_temps_fcn(band_iter,:,:,num_md_temp+j) = foreground_map_in(pixels,:)
          *>                   end do
          *>                end do
          *>                deallocate(temp_names_fcn)
          *>                
          *>             else
          *>                do j = 1, num_fg_temp-num_md_temp
          *>                   do band_iter = 1, numband
          *>                      if (band_iter == map_id) then
          *>                         call mpi_bcast(foreground_map_in, size(foreground_map_in), &
          *>                              & MPI_DOUBLE_PRECISION, root, comm_alms, ierr)
          *>                      end if
          *>                      fg_temps_fcn(band_iter,:,:,num_md_temp+j) = foreground_map_in(pixels,:)
          *>                   end do
          *>                end do
          *>             end if
          *>             deallocate(foreground_map_in)
          *>   
          *>             if (polarization .and. (.not. sample_T_modes)) fg_temps_fcn(:,:,1,:) = 0.d0
          *>   
          *>          end if
          *>       end if
          *>    end if
          .>    ...
          M>    if (sample_fg_pix) then
          M>       allocate(fg_pix_spec_response(0:map_size-1, nmaps, num_fg_comp))
          A>       if (freq_corr_noise) then
          A>          allocate(fg_pix_spec_responses_fcn(numband, 0:map_size-1, nmaps, num_fg_comp))
          A>       end if
          A>    end if  
          .>    ...
          A>       if (freq_corr_noise) then
          A>          allocate(inv_Ns_scaled_fcn(numband, 0:npix-1, nmaps, numband))
          A>          allocate(inv_Ns_lowres_fcn(numband, 0:npix-1, nmaps, numband))
          A>       end if
          .>    ...
       **** ADDED PROCEDURE ****
          *>    if (.not. freq_corr_noise) then
          *>       do i = 1, numband
          *>          call int2string(i, map_text)
          *> 
          *>          paramtext = 'NOISE_RMS' // map_text
          *>          call get_parameter(paramfile, trim(paramtext), par_string=rmsfile)
          *>          paramtext = 'REG_NOISE_SCALE' // map_text
          *>          call get_parameter(paramfile, trim(paramtext), par_dp=my_reg_scale)
          *>          paramtext = 'REGULARIZATION_NOISE'
          *>          call get_parameter(paramfile, trim(paramtext), par_dp=my_reg_noise)
          *>          my_reg_noise = my_reg_noise * my_reg_scale
          *> 
          *>          allocate(map_in(0:npix-1,nmaps))
          *>          call read_map(rmsfile, map_in)
          *>          if (my_reg_noise > 0.d0) then
          *>             map_in = my_reg_noise
          *>          else if (my_reg_noise < 0.d0) then
          *>             map_in = sqrt(map_in**2 + my_reg_noise**2)
          *>          end if
          *>          do j = 0, npix-1
          *>             do k = 1, nmaps
          *>                if ((mask_lowres(j,k) > 0.5d0 .or. sample_inside_mask) .and. map_in(j,k) > 0.d0) then
          *>                   inv_N_lowres(j,k,i) = 1.d0 / map_in(j,k)**2
          *>                end if
          *>             end do
          *>          end do
          *>          deallocate(map_in)
          *>       end do
          *>    else
          *>       do i = 1, numband
          *>          call int2string(i, map_text)
          *>          do band_iter = 1, numband
          *>             call int2string(band_iter, map2_text)
          *>             
          *>             paramtext = 'NOISE_RMS' // map2_text
          *>             call get_parameter(paramfile, trim(paramtext), par_string=rmsfile)
          *>             paramtext = 'REG_NOISE_SCALE' // map2_text
          *>             call get_parameter(paramfile, trim(paramtext), par_dp=my_reg_scale)
          *>             paramtext = 'REGULARIZATION_NOISE'
          *>             call get_parameter(paramfile, trim(paramtext), par_dp=my_reg_noise)
          *>             my_reg_noise = my_reg_noise * my_reg_scale
          *> 
          *>             allocate(map_in(0:npix-1,nmaps))
          *>             call read_map(rmsfile, map_in)
          *>             if (my_reg_noise > 0.d0) then
          *>                map_in = my_reg_noise
          *>             else if (my_reg_noise < 0.d0) then
          *>                map_in = sqrt(map_in**2 + my_reg_noise**2)
          *>             end if
          *>             do j = 0, npix-1
          *>                do k = 1, nmaps
          *>                   if ((mask_lowres(j,k) > 0.5d0 .or. sample_inside_mask) .and. map_in(j,k) > 0.d0) then
          *>                      inv_Ns_lowres_fcn(band_iter,j,k,i) = 1.d0 / map_in(j,k)**2
          *>                   end if
          *>                end do
          *>             end do
          *>             deallocate(map_in)
          *>          end do
          *>       end do
          *>    end if 
          .>    ...
       **** ADDED PROCEDURE ****
          *>    if (sample_fg_pix) then
          *>       if (.not. allocated(inv_N_lowres)) allocate(inv_N_lowres(0:npix-1, nmaps, numband))
          *>       if (.not. allocated(inv_N_scaled)) allocate(inv_N_scaled(0:npix-1, nmaps, numband))
          *>       call mpi_bcast(inv_N_lowres, size(inv_N_lowres), MPI_DOUBLE_PRECISION, root, comm_chain, ierr)
          *>       inv_N_scaled = inv_N_lowres
          *>       if (freq_corr_noise) then
          *>          if (.not. allocated(inv_Ns_lowres_fcn)) allocate(inv_Ns_lowres_fcn(numband, 0:npix-1, nmaps, numband))
          *>          if (.not. allocated(inv_Ns_scaled_fcn)) allocate(inv_Ns_scaled_fcn(numband, 0:npix-1, nmaps, numband))
          *>          inv_Ns_scaled_fcn = inv_Ns_lowres_fcn
          *>       end if
          *>    end if
          .>    ...
          .>  end subroutine initialize_data_mod
          
    >> "comm_signal_mod.f90" IMPORTS FROM "comm_Cl_sampling_mod.f90"             
    >> "comm_mp_mod.f90" IMPORTS FROM "comm_data_mod.f90"             
    >> "comm_noisesamp_mod.f90" IMPORTS FROM "comm_N_mult_mod.f90"
    >> "comm_cgd_matmul_mod.f90" IMPORTS FROM "comm_data_mod.f90" 
    >> FROM "comm_direct_sol_mod.f90"
          .>  subroutine initialize_direct_solution_mod(paramfile)
          .>    ...
          .>    call genvec2linvec(s, x)
          .>      subroutine genvec2linvec(a, b)
          M>        real(dp),     allocatable, dimension(:)         :: b, c
          .>        ...
          .>        m = size(a%cmb_amp)
          A>        allocate(c(m))
          M>        b(n:n+m-1) = reshape(a%cmb_amp, shape(c))
          A>        deallocate(c)
          .>        ...
          .>        if (num_fg_temp > 0) then
          .>          m = num_fg_temp
          A>          allocate(c(m))
          M>          b(n:n+m-1) = reshape(a%temp_amp, shape(c))
          A>          deallocate(c)
          .>        ...
          .>        if (sample_fg_pix) then
          .>          m = size(a%fg_amp)
          A>          allocate(c(m))
          M>          b(n:n+m-1) = reshape(a%fg_amp, shape(c))
          A>          deallocate(c)
          .>        ...

    >> "comm_chisq_mod.f90" IMPORTS FROM "comm_data_mod.f90"
    
A>  if (.not. freq_corr_noise) then
M>     call update_fg_pix_response_map(map_id, pixels, fg_pix_spec_response, fg_param_map_in = fg_param_map)
A>  else
A>     call update_fg_pix_response_map(map_id, pixels, fg_pix_spec_response, fg_pix_spec_responses_fcn, fg_param_map_in = fg_param_map)
A>  end if  

ALSO IN comm_mp_mod.f90: subroutine slave_carry_out_operation(slave_work)
                     .>     ...
                     .>     else if (operation == 12) then
                     A>        if (.not. freq_corr_noise) then
                     M>           call update_fg_pix_response_map(map_id, pixels, fg_pix_spec_response)
                     A>        else
                     A>           call update_fg_pix_response_map(map_id, pixels, fg_pix_spec_response, &
                     A>                   & fg_pix_spec_responses_fcn)
                     A>        end if

                          subroutine update_fg_pix_response_maps(index_map)
                     .>      ...
                     A>        if (.not. freq_corr_noise) then
                     M>           call update_fg_pix_response_map(map_id, pixels, fg_pix_spec_response, fg_param_map_in = index_map))
                     A>        else
                     A>           call update_fg_pix_response_map(map_id, pixels, fg_pix_spec_response, fg_pix_spec_responses_fcn, &
                     A>                   & fg_param_map_in = index_map)
                     A>        end if

    >> "comm_fg_component_mod.f90" IMPORTS FROM "comm_bp_mod.f90"
          .>  subroutine update_fg_pix_response_map(...)
          A>    real(dp),     dimension(1:,0:,1:,1:), intent(out)          :: fg_pix_spec_responses_fcn
          M>    integer(i4b) :: i, j, k, p, numpix_highres, pix_nest, pix_ring, ierr, band_iter
          .>    ...
          A>                if (.not. freq_corr_noise) then
          M>                   fg_pix_spec_response(i,j,k) = 0.d0
          A>                else
          A>                   do band_iter = 1, numband
          A>                      fg_pix_spec_responses_fcn(band_iter,i,j,k) = 0.d0
          A>                   end do
          A>                end if
          A>             else
          A>                if (.not. freq_corr_noise) then
          M>                   fg_pix_spec_response(i,j,k) = &
          M>                        & get_effective_fg_spectrum(fg_components(k), band, fg_par%comp(k)%p(j,:), &
          M>                        & pixel=i, pol=j)
          A>                else
          A>                   do band_iter = 1, numband
          A>                      fg_pix_spec_responses_fcn(band_iter,i,j,k) = &
          A>                           & get_effective_fg_spectrum(fg_components(k), band_iter, fg_par%comp(k)%p(j,:), &
          A>                           & pixel=i, pol=j)
          A>                   end do
          A>                end if
          .>  end subroutine update_fg_pix_response_map
          
    >> "comm_cgd_precond_mod.f90" IMPORTS FROM "comm_cgd_matmul_mod.f90"
          .>  subroutine pre_initialize_preconditioner(chain_dir, comm_chain_in, comm_data_in, comm_alms_in, comm_master, &
                         & paramfile)
          .>    ...
          .>    ! Precompute low-l + template block
          .>          call initialize_inv_N_lowl(comm_master)
          .>             subroutine initialize_inv_N_lowl(comm_master)
          .>               ...
          .>                           call compute_Au(x, y)
comm_cgd_matmul_mod.f90: .>               subroutine compute_Au(vec_in, vec_out)
                         .>                 ...
                         .>                 call compute_At_invN_A_x(vec_in, vec_out)
                         .>                    subroutine compute_At_invN_A_x(coeff_in, coeff_out)
                         M>                      integer(i4b) :: i, j, k, l, band_iter
                         A>                      real(dp), allocatable, dimension(:,:,:) :: map_sums_fcn
                         .>                      ...
                         A>                      if (freq_corr_noise) then
                         A>                         allocate(map_sums_fcn(numband,0:map_size-1,nmaps))
                         A>                         map_sums_fcn = 0.d0
                         A>                      end if   
                         .>                      ...
                      **** ADDED PROCEDURE ****
                         *>                      ! Add CMB term
                         *>                      if (.not. freq_corr_noise) then
                         *>                         if (.not. enforce_zero_cl .and. mask_state == OUTSIDE_MASK) then
                         *>                            map = 0.d0
                         *>                            if (myid_alms == root) then
                         *>                               allocate(alms1(numcomp,nmaps))
                         *>                               alms1 = spec2data(map_id, cmb=.true.) * v1%cmb_amp
                         *>                               call multiply_with_beam(alms1)
                         *>                               call wall_time(t1)
                         *>                               call convert_harmonic_to_real_space(map, alms1)
                         *>                               call wall_time(t2)
                         *>                  !             write(*,*) 'Wall SHT1 = ', t2-t1
                         *>                               deallocate(alms1)
                         *>                            else
                         *>                               call convert_harmonic_to_real_space(map)
                         *>                            end if
                         *>                            map_sum = map_sum + map 
                         *>                         else
                         *>                            if (.not. enforce_zero_cl .and. mask_state == OUTSIDE_MASK) then
                         *>                               do band_iter = 1, numband
                         *>                                  map = 0.d0
                         *>                                  if (myid_alms == root) then
                         *>                                     allocate(alms1(numcomp,nmaps))
                         *>                                     alms1 = spec2data(band_iter, cmb=.true.) * v1%cmb_amp
                         *>                                     call multiply_with_beam(alms1, band_id_in=band_iter)
                         *>                                     call wall_time(t1)
                         *>                                     call convert_harmonic_to_real_space(map, alms1)
                         *>                                     call wall_time(t2)
                         *>                     !                write(*,*) 'Wall SHT1 = ', t2-t1
                         *>                                     deallocate(alms1)
                         *>                                  else
                         *>                                     call convert_harmonic_to_real_space(map)   !!!
                         *>                                  end if
                         *>                                  map_sums_fcn(band_iter,:,:) = map_sums_fcn(band_iter,:,:) + map
                         *>                               end do 
                         *>                            end if    
                         *>                         end if                      
comm_beam_mod.f90:          M> subroutine multiply_with_beam(alms, deconvolve, use_transfer, transpose, band_id_in)
                            A>   integer(i4b),                   intent(in),   optional :: band_id_in
                            .>   ...
                         **** ADDED PROCEDURE ****              
                            *>    ! Do the convolution
                            *>    if (.not. freq_corr_noise) then
                            *>       if (transfer) then
                            *>          j = 1
                            *>          do l = 0, lmax
                            *>             do m = -l, l
                            *>                 if (deconv) then
                            *>                   alms(j,:) = alms(j,:) / beam(l,:)
                            *>                else
                            *>                   alms(j,:) = alms(j,:) * beam(l,:)
                            *>                end if
                            *>                j = j+1
                            *>             end do
                            *>          end do
                            *>       else 
                            *>
                            *>       end if
                            *>    else
                            *>       if (transfer) then
                            *>          j = 1
                            *>          do l = 0, lmax
                            *>             do m = -l, l
                            *>                 if (deconv) then
                            *>                   alms(j,:) = alms(j,:) / beams_fcn(band_id_in,l,:)
                            *>                else
                            *>                   alms(j,:) = alms(j,:) * beams_fcn(band_id_in,l,:)
                            *>                end if
                            *>                j = j+1
                            *>             end do
                            *>          end do
                            *>       else 
                            *>
                            *>       end if    
                            *>    end if
                            .>
                      **** ADDED PROCEDURE ****
comm_cgd_matmul_mod.f90: *>                      if (mask_state == OUTSIDE_MASK .and. sample_temp_coeffs) then
                         *>                         call wall_time(t1)
                         *>                         ! Add free template term
                         *>                         do l = 1, num_fg_temp
                         *>                            if (.not. freq_corr_noise) then
                         *>                               if (.not. fix_temp(l,map_id)) map_sum = map_sum + v1%temp_amp(l,map_id) * fg_temp(:,:,l)
                         *>                            else
                         *>                               do band_iter = 1, numband
                         *>                                  if (.not. fix_temp(l,band_iter)) map_sums_fcn(band_iter,:,:) = map_sums_fcn(band_iter,:,:) + v1%temp_amp(l,band_iter) * fg_temps_fcn(band_iter,:,:,l)
                         *>                               end do
                         *>                            end if
                         *>                         end do
                         *>                         call wall_time(t2)
                         *>                          write(*,*) 'Wall temp1 = ', t2-t1
                         *>                      end if
                         *>                      
                         *>                      ! Add pixel foreground term
                         *>                      do l = 1, num_fg_signal
                         *>                         if (fg_components(l)%enforce_positive_amplitude) cycle
                         *>                         if (.not. enforce_zero_cl .and. trim(fg_components(l)%type) == 'cmb') cycle
                         *>                         if (.not. freq_corr_noise) then
                         *>                            map_sum = map_sum + fg_pix_spec_response(:,:,l) * v1%fg_amp(pixels,:,l)
                         *>                         else
                         *>                            do band_iter = 1, numband
                         *>                               map_sums_fcn(band_iter,:,:) = map_sums_fcn(band_iter,:,:) + fg_pix_spec_responses_fcn(band_iter,:,:,l) * v1%fg_amp(pixels,:,l)
                         *>                            end do
                         *>                         end if
                         *>                      end do
                         *>                  
                         *>                      call wall_time(t1)
                         *>                      if (.not. freq_corr_noise) then
                         *>                         call multiply_by_inv_N(map_sum)
                         *>                      else
                         *>                         do band_iter = 1, numband
                         *>                            if (trim(noise_format) == 'rms') then
                         *>                               call initialize_invN_rms_fcn(band_iter)
                         *>                            else if (trim(noise_format) == 'dense_matrix') then
                         *>                               call initialize_invN_dense_fcn(map_id, band_iter) 
                         *>                            end if
                         *>                            call multiply_by_inv_N(map_sums_fcn(band_iter,:,:))
                         *>                            map_sum = map_sum + map_sums_fcn(band_iter,:,:)
                         *>                         end do
                         *>                      end if
                         *>                      call wall_time(t2)
                         *>                  !    write(*,*) 'Wall invN = ', t2-t1  
                         .>                  ...
                         A>                  if (.not. freq_corr_noise) then
                         M>                     v2%temp_amp(i,map_id) = v2%temp_amp(i,map_id) + sum(fg_temp(:,:,i)*map_sum)
                         A>                  else
                         A>                     v2%temp_amp(i,map_id) = v2%temp_amp(i,map_id) + sum(fg_temps_fcn(map_id,:,:,i)*map_sum)
                         A>                  end if
                         .>                  ...
                         A>                  if (.not. freq_corr_noise) then
                         M>                     v2%fg_amp(pixels,:,i) = v2%fg_amp(pixels,:,i) + fg_pix_spec_response(:,:,i) * map_sum
                         A>                  else
                         A>                     v2%fg_amp(pixels,:,i) = v2%fg_amp(pixels,:,i) + fg_pix_spec_responses_fcn(map_id,:,:,i) * map_sum
                         A>                  end if                         
                         .>                  ...
                         A>                  if (freq_corr_noise) deallocate(map_sums_fcn)
                         .>                end subroutine compute_At_invN_A_x
          .>               ...
          .>             end subroutine initialize_inv_N_lowl
          .>    ...
          .>  end subroutine pre_initialize_preconditioner
          
    >> "comm_mcmc_mod.f90" IMPORTS FROM "comm_Cl_util_mod.f90"



>>>> NOTES: modules that contain 'map_id' or 'myid_data':
     - comm_fg_mod.f90:           not in initialization (only in 'call compute_total_chisq')
   ! - comm_beam_mod.f90:         MAP_ID IN INITIALIZATION
   ! - comm_N_mult_mod.f90:       MAP_ID IN INITIALIZATION     
   ! - comm_data_mod.f90:         MAP_ID .and. MYID_DATA IN INITIALIZATION
     - comm_mp_mod.f90:           not in initialization
     - comm_noisesamp_mod.f90:    not in initialization (only in 'call compute_chisq')
     - comm_cgd_matmul_mod.f90:   not in initialzation
   ! - comm_chisq_mod.f90:        MYID_DATA IN INITIALIZATION
   ! - comm_cgd_precond_mod.f90:  MAP_ID .and. MYID_DATA IN PRE-INITIALIZATION
     - comm_mcmc_mod.f90:         not in initialization (only in 'call compute_chisq')
   


####################################
###### CARRY OUT COMPUTATIONS ######
####################################

commander.f90:     .>  call read_map_realization(paramfile, i)
comm_data_mod.f90: .>    subroutine read_map_realization(paramfile, realization_id)
                   M>      integer(i4b)       :: ierr, i, j, k, band_iter, map_id_fcn
                   .>      ...
                **** ADDED PROCEDURE ****
                   *>      if (.not. freq_corr_noise) then
                   *>         call int2string(map_id, map_text)
                   *>         call int2string(realization_id, realization_text)
                   *>      
                   *>         ! Get filenames
                   *>         paramtext = 'MAP' // map_text // '_' // realization_text
                   *>         call get_parameter(paramfile, trim(paramtext), par_string=cmbfile)
                   *>   
                   *>         ! Read the CMB data
                   *>         allocate(map_in(0:npix-1,nmaps))
                   *>         if (myid_alms == root) then
                   *>            call read_map(cmbfile, map_in)
                   *>            call rand_init(noise_handle, map_id)
                   *>            do j = 1, nmaps
                   *>               do i = 0, npix-1
                   *>                  map_in(i,j) = map_in(i,j) + reg_noise * rand_gauss(noise_handle)
                   *>               end do
                   *>            end do
                   *>         end if
                   *>         call mpi_bcast(map_in, size(map_in), MPI_DOUBLE_PRECISION, root, comm_alms, ierr)
                   *>         cmbmap = map_in(pixels,:)
                   *>         if (polarization .and. (.not. sample_T_modes)) cmbmap(:,1) = 0.d0
                   *>         deallocate(map_in)
                   *>      else
                   *>         allocate(map_in(0:npix-1,nmaps))
                   *>         do band_iter = 1, numband
                   *>            call int2string(band_iter, map_text)
                   *>            call int2string(realization_id, realization_text)
                   *>      
                   *>            ! Get filenames
                   *>            paramtext = 'MAP' // map_text // '_' // realization_text
                   *>            call get_parameter(paramfile, trim(paramtext), par_string=cmbfile)
                   *>  
                   *>            ! Read the CMB data
                   *>            if (myid_alms == root) then
                   *>               call read_map(cmbfile, map_in)
                   *>               call rand_init(noise_handle, band_iter)
                   *>               do j = 1, nmaps
                   *>                  do i = 0, npix-1
                   *>                     map_in(i,j) = map_in(i,j) + reg_noises_fcn(band_iter) * rand_gauss(noise_handle)
                   *>                  end do
                   *>               end do
                   *>            end if
                   *>            if (band_iter == map_id) call mpi_bcast(map_in, size(map_in), MPI_DOUBLE_PRECISION, root, comm_alms, ierr)
                   *>            cmbmaps_fcn(band_iter,:,:) = map_in(pixels,:)
                   *>         end do
                   *>         if (polarization .and. (.not. sample_T_modes)) cmbmaps_fcn(:,1,:) = 0.d0
                   *>         deallocate(map_in)
                   *>      end if
  




########################################
###### MAIN COMPUTATIONAL ROUTINE ######**************************************************************************************************
########################################

   .>  subroutine compute_single_chain(paramfile, chain, rng_handle, cl_i)
   M>    integer(i4b)       :: iter, i, j, k, l, m, num_gibbs_iter, num_step_ml_search, band_iter
   M>    logical(lgt)       :: output_ml_map_and_covmat, freq_corr_noise
   .>    ...
   A>    call get_parameter(paramfile, 'FREQ_CORR_NOISE',               par_lgt=freq_corr_noise)
   .>    ...
**** ADDED PROCEDURE ****
   *>       if (.not. freq_corr_noise) then
   *>          if (.not. all(fg_pix_spec_response == fg_pix_spec_response)) then
   *>             do j = 1, num_fg_comp
   *>                do k = 1, nmaps
   *>                   do i = 0, map_size-1 
   *>                      if (is_nan(fg_pix_spec_response(i,k,j))) then
   *>                         write(*,*) i, k, j, fg_pix_spec_response(i,k,j)
   *>                      end if
   *>                   end do
   *>                end do
   *>             end do
   *>             write(*,*) 'nan'
   *>             stop
   *>          end if
   *>       else
   *>          do band_iter = 1, numband
   *>             if (.not. all(fg_pix_spec_responses_fcn(band_iter,:,:,:) == fg_pix_spec_responses_fcn(band_iter,:,:,:))) then
   *>                do j = 1, num_fg_comp
   *>                   do k = 1, nmaps
   *>                      do i = 0, map_size-1 
   *>                         if (is_nan(fg_pix_spec_responses_fcn(band_iter,i,k,j))) then
   *>                            write(*,*) i, k, j, fg_pix_spec_responses_fcn(band_iter,i,k,j)
   *>                         end if
   *>                      end do
   *>                   end do
   *>                end do
   *>                write(*,*) 'nan'
   *>                stop
   *>             end if
   *>          end do
   *>       end if

  
   

commander.f90:     .>  call compute_residuals(s_i, .false.)
comm_mp_mod.f90:   .>    call compute_residual(s, subtract_signal)  
comm_data_mod.f90: .>      subroutine compute_residual(s, subtract_signal)
                   M>        integer(i4b) :: i, j, ierr, band_iter, map_id_fcn
                   .>        ...
                **** ADDED PROCEDURE ****
                   *>        if (.not. freq_corr_noise) then
                   *>           residual = cmbmap
                   *>           if (sub_signal) residual = residual - signal_map
                   *>    
                   *>           ! Distribute foreground amplitudes
                   *>           if (num_fg_temp > 0) then
                   *>              allocate(my_coeff(num_fg_temp, numband))
                   *>              if (myid_chain == root) my_coeff = s%temp_amp
                   *>              call mpi_bcast(my_coeff, size(my_coeff), MPI_DOUBLE_PRECISION, root, comm_chain, ierr)
                   *>              do j = 1, num_fg_temp
                   *>                 if (fix_temp(j,map_id)) residual = residual - my_coeff(j,map_id) * fg_temp(:,:,j)
                   *>              end do
                   *>              deallocate(my_coeff)
                   *>           end if
                   *>    
                   *>           if (exclude_pos_fg_amp) then
                   *>              allocate(a(0:npix-1,nmaps))
                   *>              do i = 1, num_fg_comp
                   *>                 if (fg_components(i)%enforce_positive_amplitude) then
                   *>                    if (present(s)) a = s%fg_amp(:,:,i)
                   *>                    call mpi_bcast(a, size(a), MPI_DOUBLE_PRECISION, root, comm_chain, ierr)
                   *>                    residual = residual - fg_pix_spec_response(:,:,i) * a(pixels,:)
                   *>                 end if
                   *>              end do
                   *>              deallocate(a)
                   *>           end if
                   *>        else
                   *>           do band_iter = 1, numband
                   *>              residuals_fcn(band_iter,:,:) = cmbmaps_fcn(band_iter,:,:)
                   *>              if (sub_signal) residuals_fcn(band_iter,:,:) = residuals_fcn(band_iter,:,:) - signal_map
                   *>    
                   *>              ! Distribute foreground amplitudes
                   *>              if (num_fg_temp > 0) then
                   *>                 allocate(my_coeff(num_fg_temp, numband))
                   *>                 if (myid_chain == root) my_coeff = s%temp_amp
                   *>                 if (band_iter == map_id) call mpi_bcast(my_coeff, size(my_coeff), MPI_DOUBLE_PRECISION, root, comm_chain, ierr)
                   *>                 do j = 1, num_fg_temp
                   *>                    if (fix_temp(j,band_iter)) residuals_fcn(band_iter,:,:) = residuals_fcn(band_iter,:,:) - my_coeff(j,band_iter) * fg_temps_fcn(band_iter,:,:,j)
                   *>                 end do
                   *>                 deallocate(my_coeff)
                   *>              end if
                   *>              
                   *>              if (exclude_pos_fg_amp) then
                   *>                 allocate(a(0:npix-1,nmaps))
                   *>                 do i = 1, num_fg_comp
                   *>                    if (fg_components(i)%enforce_positive_amplitude) then
                   *>                       if (present(s)) a = s%fg_amp(:,:,i)
                   *>                       if (band_iter == map_id) call mpi_bcast(a, size(a), MPI_DOUBLE_PRECISION, root, comm_chain, ierr)
                   *>                       residuals_fcn(band_iter,:,:) = residuals_fcn(band_iter,:,:) - fg_pix_spec_responses_fcn(band_iter,:,:,i) * a(pixels,:)
                   *>                    end if
                   *>                 end do
                   *>                 deallocate(a)
                   *>              end if
                   *>           end do
                   *>        end if


comm_N_mult_mod.f90: **** ADDED SUBROUTINE ****
                        *>  subroutine initialize_invN_dense_fcn(band_id_in, band_id_in2) 
                        *>    implicit none
                        *>    integer(i4b), intent(in)           :: band_id_in
                        *>    integer(i4b), intent(in), optional :: band_id_in2       
                        *>  
                        *>    integer(i4b)       :: i, n, ierr, unit
                        *>    character(len=2)   :: map_text, map2_text
                        *>    character(len=128) :: noisefile, paramtext       
                        *>    
                        *>    unit = getlun()
                        *>    
                        *>    call int2string(band_id_in, map_text)
                        *>    if (present(band_id_in2)) then
                        *>       call int2string(band_id_in2, map2_text)
                        *>    else
                        *>       call int2string(band_id_in, map2_text)
                        *>    end if
                        *>
                        *>    map_id_fcn = band_id_in2
                        *>  
                        *>    if (freq_corr_noise) then
                        *>       paramtext = 'INV_N_MAT' // trim(map_text) // trim(map2_text)
                        *>    else
                        *>       paramtext = 'INV_N_MAT' // map_text
                        *>    end if
                        *>    call get_parameter(paramfile, trim(paramtext), par_string=noisefile)
                        *>    invN_dense = 0.d0
                        *>    open(unit,file=trim(noisefile),form='unformatted')
                        *>    read(unit) n
                        *>    if (n /= numpix) then
                        *>       write(*,*) 'ERROR: Number of pixels in covariance matrix file does not match mask', n, numpix
                        *>       call mpi_finalize(ierr)
                        *>       stop
                        *>    end if
                        *>    
                        *>    read(unit) i ! Ordering
                        *>    read(unit) i ! Polarization status
                        *>    !write(*,fmt='(a,i8,i8)') 'Size of inverse noise covariance matrix         = ', n, col_to-col_from+1
                        *>    do i = 1, col_from-1
                        *>       read(unit) 
                        *>    end do
                        *>    do i = col_from, col_to
                        *>       read(unit) invN_dense(:,i)
                        *>       call mpi_barrier(mpi_comm_world, ierr)
                        *>    end do
                        *>    close(unit)
                        *>  
                        *>    if (freq_corr_noise) then
                        *>       paramtext = 'SQRT_INV_N_MAT' // trim(map_text) // trim(map2_text)
                        *>    else
                        *>       paramtext = 'SQRT_INV_N_MAT' // map_text
                        *>    end if
                        *>    call get_parameter(paramfile, trim(paramtext), par_string=noisefile)
                        *>    sqrt_invN_dense = 0.d0
                        *>    open(unit,file=trim(noisefile),form='unformatted')
                        *>    read(unit) n
                        *>    read(unit) i ! Ordering
                        *>    read(unit) i ! Polarization status
                        *>    !write(*,fmt='(a,i8,i8)') 'Size of sqrt of inverse noise covariance matrix = ', n, col_to-col_from+1
                        *>    do i = 1, col_from-1
                        *>       read(unit) 
                        *>    end do
                        *>    do i = col_from, col_to
                        *>       read(unit) sqrt_invN_dense(:,i)
                        *>    end do
                        *>    close(unit)
                        *>   
                        *>  end subroutine initialize_invN_dense_fcn
  
  
commander.f90:     A>          if (.not. freq_corr_noise) then
                   M>             call output_ml_map(paramfile)
                   A>          else
                   A>             call output_ml_map(paramfile, band_id)
                   A>          end if
  
  
commander.f90:     M> call output_ml_map(paramfile, band_id)
comm_mp_mod.f90:   M>   subroutine output_ml_map(paramfile, main_band_id)
                   A>     integer(i4b),     intent(in), optional :: main_band_id
                   .>     ...
                   M>     call output_ml_map_engine(myid_chain, paramfile, main_band_id)
comm_data_mod.f90: M>       subroutine output_ml_map_engine(myid_chain, paramfile, main_band_id_)
                   A>         integer(i4b),     intent(in), optional :: main_band_id_
                   M>         integer(i4b) :: i, j, k, l, n, i2, j2, k2, p1, p2, ierr, unit, ntot, band_iter, main_band_id
                   A>         real(dp), allocatable, dimension(:,:)   :: invN_d_fcn
                   .>         ...
                   A>         if (present(main_band_id_)) then
                   A>            main_band_id = main_band_id_
                   A>         else
                   A>            main_band_id = map_id
                   A>         end if
                   .>         ...
                **** ADDED PROCEDURE ****
                   *>         ! Set up linear system
                   *>         if (myid_chain == root) write(*,*) 'Setting up Ft*invN*F matrix'
                   *>         if (.not. freq_corr_noise) then
                   *>            map = residual
                   *>            call multiply_by_inv_N(map)
                   *>            i = 1
                   *>            do j = 1, num_fg_comp
                   *>               do k = 1, nmaps
                   *>                  do p1 = 0, npix-1
                   *>                     if (mask(p1,k)) then
                   *>                        Ft_invN_d(i) = fg_pix_spec_response(p1,k,j) * map(p1,k)
                   *>                        i            = i+1
                   *>                     end if
                   *>                  end do
                   *>               end do
                   *>            end do
                   *>         else
                   *>            allocate(invN_d_fcn(0:map_size-1,nmaps))
                   *>            invN_d_fcn = 0.d0                                                   
                   *>            do band_iter = 1, numband                                        
                   *>               map = residuals_fcn(band_iter,:,:) 
                   *>               if (trim(noise_format) == 'rms') then
                   *>                  call initialize_invN_rms_fcn(band_iter)
                   *>               else if (trim(noise_format) == 'dense_matrix') then
                   *>                  call initialize_invN_dense_fcn(main_band_id, band_iter) 
                   *>               end if
                   *>               call multiply_by_inv_N(map)                                 
                   *>               invN_d_fcn = invN_d_fcn + map
                   *>            end do                                                         
                   *>          
                   *>            i = 1
                   *>            do j = 1, num_fg_comp
                   *>               do k = 1, nmaps
                   *>                  do p1 = 0, npix-1
                   *>                     if (mask(p1,k)) then
                   *>                        Ft_invN_d(i) = fg_pix_spec_responses_fcn(main_band_id,p1,k,j) * invN_d_fcn(p1,k)
                   *>                        i            = i+1
                   *>                     end if
                   *>                  end do
                   *>               end do
                   *>            end do
                   *>         end if
                   *>            
                   *>         if (.not. freq_corr_noise) then
                   *>            i = 1
                   *>            do j = 1, num_fg_comp
                   *>               if (myid_chain == root) write(*,*) 'Component =', j, num_fg_comp
                   *>               do k = 1, nmaps
                   *>                  do p1 = 0, npix-1
                   *>                     if (mask(p1,k)) then
                   *>                        map = 0.d0
                   *>                        map(p1,k) = fg_pix_spec_response(p1,k,j)
                   *>                        call multiply_by_inv_N_column(map,p1,k)
                   *>                        
                   *>                        i2 = 1
                   *>                        do j2 = 1, num_fg_comp
                   *>                           do k2 = 1, nmaps
                   *>                              do p2 = 0, npix-1
                   *>                                 if (mask(p2,k2)) then
                   *>                                    Ft_invN_F(i,i2) = map(p2,k2) * fg_pix_spec_response(p2,k2,j2)
                   *>                                    i2              = i2+1
                   *>                                 end if
                   *>                              end do
                   *>                           end do
                   *>                        end do
                   *>                        i = i+1                
                   *>                     end if
                   *>                  end do
                   *>               end do
                   *>            end do
                   *>         else
                   *>            i = 1
                   *>            do j = 1, num_fg_comp
                   *>               if (myid_chain == root) write(*,*) 'Component =', j, num_fg_comp
                   *>               do k = 1, nmaps
                   *>                  do p1 = 0, npix-1
                   *>                     if (mask(p1,k)) then
                   *>                        invN_d_fcn = 0.d0                                                 
                   *>                        do band_iter = 1, numband                                         
                   *>                           map = 0.d0                                                     
                   *>                           map(p1,k) = fg_pix_spec_responses_fcn(band_iter,p1,k,j)        
                   *>                           if (trim(noise_format) == 'rms') then
                   *>                              call initialize_invN_rms_fcn(band_iter)
                   *>                           else if (trim(noise_format) == 'dense_matrix') then
                   *>                              call initialize_invN_dense_fcn(main_band_id, band_iter) 
                   *>                           end if
                   *>                           call multiply_by_inv_N_column(map,p1,k)                     
                   *>                           invN_d_fcn = invN_d_fcn + map 
                   *>                        end do                                             
                   *>                                                                           
                   *>                        i2 = 1                                             
                   *>                        do j2 = 1, num_fg_comp                             
                   *>                           do k2 = 1, nmaps                                
                   *>                              do p2 = 0, npix-1                            
                   *>                                 if (mask(p2,k2)) then                     
                   *>                                    Ft_invN_F(i,i2) = invN_d_fcn(p2,k2) * fg_pix_spec_responses_fcn(main_band_id,p2,k2,j2)
                   *>                                    i2              = i2+1
                   *>                                 end if
                   *>                              end do
                   *>                           end do
                   *>                        end do
                   *>                        i = i+1                
                   *>                     end if
                   *>                  end do
                   *>               end do
                   *>            end do
                   *>            deallocate(invN_d_fcn)
                   *>         end if
                   .>       ...
                   .>       end subroutine output_ml_map_engine                  
                   
                   
comm_N_mult_mod.f90: .>  ...
                  **** ADDED SUBROUTINE ****
                     *>  subroutine multiply_by_inv_N_column(map_in, row_, stokes, N_format, do_sqrt)
                     *>    implicit none
                     *>
                     *>    real(dp),     dimension(0:,1:), intent(inout)  :: map_in
                     *>    integer(i4b),                   intent(in)     :: row_, stokes
                     *>    character(len=*),               intent(in), optional :: N_format
                     *>    logical(lgt),                   intent(in), optional :: do_sqrt
                     *>
                     *>    integer(i4b)                        :: i, j, ierr
                     *>    character(len=128)                  :: N_format_
                     *>    logical(lgt)                        :: do_sqrt_
                     *>    real(dp)                            :: value
                     *>    real(dp), allocatable, dimension(:) :: map_lin, map_lin2
                     *>
                     *>    if (present(N_format)) then
                     *>       N_format_ = N_format
                     *>    else
                     *>       N_format_ = noise_format
                     *>    end if
                     *>
                     *>    if (present(do_sqrt)) then
                     *>       do_sqrt_ = do_sqrt
                     *>    else
                     *>       do_sqrt_ = .false.
                     *>    end if
                     *>
                     *>    if (trim(N_format_) == 'rms') then
                     *>       
                     *>       ! Multiply with the inverse noise covariance matrix
                     *>       if (do_sqrt_) then
                     *>          map_in = sqrt_invN_rms(row,stokes,mask_state)*map_in
                     *>       else
                     *>          map_in = invN_rms(row,stokes,mask_state)*map_in
                     *>       end if
                     *>       
                     *>    else if (trim(N_format_) == 'dense_matrix') then
                     *>    
                     *>       if (inv_N_order == 2) then
                     *>          do i = 1, nmaps
                     *>             call convert_ring2nest(nside, map_in(:,i))
                     *>             do j = 0, npix-1
                     *>                if (map_in(j,i) /= 0.d0) then
                     *>                   value = map_in(j,i)
                     *>                   row = j
                     *>                end if
                     *>             end do
                     *>          end do
                     *>       else
                     *>          row = row_
                     *>       end if
                     *>
                     *>       ! Multiply with N^-1
                     *>       if (numprocs == 1) then
                     *>          if (do_sqrt_) then
                     *>             do i = 1, nmaps
                     *>                map_in(:,i) = value * sqrt_invN_dense((i-1)*npix+1:i*npix+1,row + (stokes-1)*npix + 1) 
                     *>             end do
                     *>          else
                     *>             do i = 1, nmaps
                     *>                map_in(:,i) = value * invN_dense((i-1)*npix+1:i*npix+1,row + (stokes-1)*npix + 1) 
                     *>             end do
                     *>          end if
                     *>       else
                     *>          allocate(map_lin2(numpix), map_lin(numpix))
                     *>          if (do_sqrt_) then
                     *>             call dgemv('N', numpix, size(invN_dense(1,:)), 1.d0, sqrt_invN_dense, numpix, & 
                     *>                        & map_lin2(col_from:col_to), 1, 0.d0, map_lin, 1)
                     *>          else
                     *>             call dgemv('N', numpix, size(invN_dense(1,:)), 1.d0, invN_dense, numpix, &   
                     *>                        & map_lin2(col_from:col_to), 1, 0.d0, map_lin, 1)
                     *>          end if
                     *>          call mpi_allreduce(map_lin, map_lin2, numpix, MPI_DOUBLE_PRECISION, MPI_SUM, comm_alms, ierr)
                     *>          map_in = reshape(map_lin2,shape(map_in))       
                     *>          deallocate(map_lin, map_lin2)
                     *>       end if
                     *>
                     *>       if (inv_N_order == 2) then
                     *>          do i = 1, nmaps
                     *>             call convert_nest2ring(nside, map_in(:,i))
                     *>          end do
                     *>       end if  
                     *>
                     *>    end if
                     *>                     
                     *>    if (do_sqrt_) then
                     *>       if (freq_corr_noise) then
                     *>          map_in = map_in / noiseamp(map_id_fcn)
                     *>       else
                     *>          map_in = map_in / noiseamp(map_id)
                     *>       end if
                     *>    else
                     *>       if (freq_corr_noise) then
                     *>          map_in = map_in / noiseamp(map_id_fcn)**2
                     *>       else
                     *>          map_in = map_in / noiseamp(map_id)**2
                     *>       end if
                     *>    end if        
                     *>
                     *>  end subroutine multiply_by_inv_N_column
                     .>  ...
                     .>  subroutine multiply_by_noise_matrix(do_sqrt, map_in, map_out, N_format)
                     M>    if (do_sqrt) then
                     A>       if (freq_corr_noise) then
                     A>          map_out = map_out / noiseamp(map_id_fcn)
                     A>       else
                     M>          map_out = map_out / noiseamp(map_id)
                     A>       end if
                     A>    else
                     A>       if (freq_corr_noise) then
                     A>          map_out = map_out / noiseamp(map_id_fcn)**2
                     A>       else
                     M>          map_out = map_out / noiseamp(map_id)**2
                     A>       end if
                     A>    end if
                     .>  end subroutine multiply_by_noise_matrix


commander.f90:   .> if (.not. freq_corr_noise) then
                 .>    call init_ind_by_nonlin_search(residuals_lowres, inv_N_scaled, fg_param_map, s_i%fg_amp)
                 .> else
                 .>    call init_ind_by_nonlin_search(residuals_lowres, inv_N_scaled, fg_param_map, s_i%fg_amp, inv_Ns_scaled_fcn)
                 .> end if
comm_mp_mod.f90: M>   subroutine init_ind_by_nonlin_search(residuals, inv_N_noise, index_map, fg_amp, inv_Ns_noise)
                 A>     real(dp), dimension(1:,0:,1:,1:), intent(in), optional :: inv_Ns_noise
                 .>     ...
                 A>     if (present(inv_Ns_noise)) then
                 M>        call init_ind(residuals, inv_N_noise, index_map, fg_amp, inv_Ns_noise)
                 A>     else
                 A>        call init_ind(residuals, inv_N_noise, index_map, fg_amp)
                 A>     end if                 
comm_fg_mod.f90: A>     real(dp), allocatable, dimension(:,:),   private :: my_inv_Ns_fcn
                 A>     real(dp), allocatable, dimension(:,:,:), private :: all_inv_Ns_fcn
                 .>     ...
                 M>     subroutine init_ind(residuals_in, inv_N_in, index_map, fg_amp, inv_Ns_in_fcn)
                 A>       real(dp), dimension(1:,0:,1:,1:), intent(in),    optional :: inv_Ns_in_fcn
                 .>       ...
                 A>       if (.not. freq_corr_noise) then
                 M>          allocate(all_inv_N(0:npix-1,numband))
                 A>       else if (freq_corr_noise .and. present(inv_Ns_in_fcn)) then
                 A>          allocate(all_inv_Ns_fcn(numband,0:npix-1,numband))
                 A>       end if
                 .>       ...
                 A>          if (.not. freq_corr_noise) then
                 M>             all_inv_N     = inv_N_in(:,1,:)
                 A>          else if (freq_corr_noise .and. present(inv_Ns_in_fcn)) then
                 A>             all_inv_Ns_fcn = inv_Ns_in_fcn(:,:,1,:)
                 A>          end if
                 .>       ...   
                 A>       if (.not. freq_corr_noise) then
                 M>          call mpi_bcast(all_inv_N,     size(all_inv_N),     MPI_DOUBLE_PRECISION, root, comm_chain, ierr)
                 A>       else if (freq_corr_noise .and. present(inv_Ns_in_fcn)) then
                 A>          call mpi_bcast(all_inv_Ns_fcn(map_id,:,:), size(all_inv_Ns_fcn(map_id,:,:)), &
                 A>                                                           & MPI_DOUBLE_PRECISION, root, comm_chain, ierr)  
                 A>       end if
                 .>       ...
                 A>       if (.not. freq_corr_noise) then
                 M>          allocate(my_inv_N(numband))
                 A>       else if (freq_corr_noise .and. present(inv_Ns_in_fcn)) then
                 A>          allocate(my_inv_Ns_fcn(numband,numband))
                 A>       end if
                 .>       ...
                 A>          if (.not. freq_corr_noise) then
                 M>             my_inv_N    = all_inv_N(p,:)
                 A>          else if (freq_corr_noise .and. present(inv_Ns_in_fcn)) then
                 A>             my_inv_Ns_fcn = all_inv_Ns_fcn(:,p,:)
                 A>          end if
                 .>       ...        
                 .>                chisq0         = fg_init_chisq(x/scale_reg)       
comm_fg_mod.f90: .>                  function fg_init_chisq(p)
                 M>                    integer(i4b) :: i, j, k, l, npar, band_iter
                 A>                    real(dp) :: s_main_fcn, contraction_fcn
                 .>                    ...
              **** ADDED PROCEDURE ****
                 *>                    chisq = 0.d0
                 *>                    if (.not. freq_corr_noise) then
                 *>                       do i = 1, numband
                 *>                          s = 0.d0
                 *>                          l = 1
                 *>                          do k = 1, num_fg_comp
                 *>                             signal = fg_amp(k) * get_effective_fg_spectrum(fg_components(k), i, &
                 *>                                  & fg_ind(l:l+fg_components(k)%npar-1), pixel=pix_init, pol=1)
                 *>                             s = s + signal
                 *>                             l = l + fg_components(k)%npar
                 *>                          end do
                 *>                          chisq = chisq + (my_residual(i)-s)**2 * (N_scale*my_inv_N(i))
                 *>                       end do
                 *>                    else
                 *>                       do i = 1, numband
                 *>                          s_main_fcn = 0.d0
                 *>                          contraction_fcn = 0.d0
                 *>                          do band_iter = 1, numband
                 *>                             s = 0.d0
                 *>                             l = 1
                 *>                             do k = 1, num_fg_comp
                 *>                                signal = fg_amp(k) * get_effective_fg_spectrum(fg_components(k), band_iter, &
                 *>                                     & fg_ind(l:l+fg_components(k)%npar-1), pixel=pix_init, pol=1)
                 *>                                s = s + signal
                 *>                                l = l + fg_components(k)%npar
                 *>                                if (band_iter == i) s_main_fcn = s_main_fcn + signal
                 *>                             end do
                 *>                             contraction_fcn = contraction_fcn + (my_residual(band_iter)-s) * (N_scale*my_inv_Ns_fcn(band_iter,i))
                 *>                          end do  
                 *>                          chisq = chisq + (my_residual(i)-s_main_fcn) * contraction_fcn
                 *>                       end do
                 *>                    end if
                 .>                    ...
                 .>                  end function fg_init_chisq
comm_fg_mod.f90: .>       ...     
                 A>                      if (.not. freq_corr_noise) then
                 M>                         if (any(all_inv_N(p,:) /= 0.d0)) index_map(p,1,k) = buffer(p,1,k)
                 A>                      else
                 A>                         if (any(all_inv_Ns_fcn(:,p,:) /= 0.d0)) index_map(p,1,k) = buffer(p,1,k)
                 A>                      end if  
                 .>       ...
              **** ADDED PROCEDURE ****
                 *>             if (.not. freq_corr_noise) then
                 *>                if (any(all_inv_N(p,:) /= 0.d0)) then
                 *>                   fg_amp(p,1,:) = buffer(p,1,:)
                 *>                   do i = 1, num_fg_comp
                 *>                      if (fg_components(i)%mask(p,1) < 0.5d0) fg_amp(p,1,i) = 0.d0
                 *>                   end do
                 *>                end if
                 *>             else
                 *>                if (any(all_inv_Ns_fcn(:,p,:) /= 0.d0)) then
                 *>                   fg_amp(p,1,:) = buffer(p,1,:)
                 *>                   do i = 1, num_fg_comp
                 *>                      if (fg_components(i)%mask(p,1) < 0.5d0) fg_amp(p,1,i) = 0.d0
                 *>                   end do
                 *>                end if
                 *>             end if  
                 .>       ...
                 M>       deallocate(A, x, x_prop, b, M, all_residuals, my_residual, scale_reg)
                 A>       if (.not. freq_corr_noise) then
                 M>          deallocate(all_inv_N, my_inv_N)
                 A>       else
                 A>          deallocate(all_inv_Ns_fcn, my_inv_Ns_fcn)
                 A>       end if
                 .>       ...
                 .>     end subroutine init_ind
  
  
  
###############################
###### SAMPLE AMPLITUDES ######
###############################
### NOTE:
### ++++ 's_i' is a genvec object, i.e.:
### ----    type genvec
### ----       real(dp), allocatable, dimension(:,:)     :: cmb_amp   !! (numcomp, nmaps)
### ----       real(dp), allocatable, dimension(:,:,:)   :: fg_amp    !! (0:npix-1, nmaps, num_signal)
### ----       real(dp), allocatable, dimension(:,:)     :: temp_amp  !! (num_fg_temp, numband)
### ----    end type genvec
### ----
### ---- (1) 'temp_amp' comes from:
### ---- commander.f90:     .> ! Initialize template amplitudes
### ----                    .> do i = 1, numband
### ----                    .>    do j = 1, num_fg_temp
### ----                    .>       s_i%temp_amp(j,i) = tempamp(j,i)
### ---- comm_data_mod.f90: .>          allocate(tempamp(num_fg_temp,numband))
### ----                    .>          inquire(file=trim(temp_amp_file), exist=exist)  !! TEMPLATE_AMP_INPUT
### ----                    .>          if (exist) then
### ----                    .>             open(unit, file=trim(temp_amp_file))
### ----                    .>             do i = 1, numband
### ----                    .>                read(unit,*) label, tempamp(:,i)
### ----                    .>             end do
### ----                    .>             close(unit)
### ----                    .>          else
### ----                    .>             tempamp = 0.d0
### ----                    .>          end if
### ----
### ---- (2) 'fg_amp' comes from:
### ---- commander.f90: .> ! Initialize foreground amplitudes
### ----                .> call init_fg_amps(paramfile, s_i%fg_amp)
### ---- commander.f90: .>    fg_amp = 0.d0
### ----                .>    do i = 1, num_fg_comp
### ----                .>       if (trim(fg_components(i)%type) == 'freefree_EM') then
### ----                .>          fg_amp(:,:,i) = 1.d0
### ----                .>          cycle
### ----                .>       end if
### ----                .> 
### ----                .>       call int2string(i, i_text)
### ----                .>       call get_parameter(paramfile, 'INITIAL_AMPLITUDE_MAP'//i_text, par_string=filename)
### ----                .>       inquire(file=trim(filename), exist=exist)
### ----                .>       if (exist) then
### ----                .>          call read_map(filename, fg_amp(:,:,i))
### ----                .>       end if
### ----                .> 
### ----                .>       ! Convert from external native units to internal antenna temperature units
### ----                .>       scale = ant2unit(fg_components(i)%amp_unit, fg_components(i)%nu_ref, &
### ----                .>            & band_ref=fg_components(i)%ref_band)
### ----                .>       fg_amp(:,:,i) = fg_amp(:,:,i) / scale
### ----                .> 
### ----                .>    end do
### ----
### ---- (3) 'cmb_amp' is 0.d0 up to 'call sample_signal_component' in commander.f90
### ----
### ++++ From 'compute_signal_rhs' in comm_cgd_matmul.f90:
### ---- (1) > 'rhs' is a genvec object initialized to 0.d0.
### ---- (2) > in 'if (add_wf) then ...'            map_sum is N^{-1}_{\nu0} x residual_{\nu0} 
### ----                                            (if freq_corr_noise >> SUM_i N^{-1}_{\nui} x residuals_fcn_{\nui})
### ---- (3) > in 'if (add_N_omega) then ...'       eta is sqrt N^{-1}_{\nu0} x gauss
### ----                                            (if freq_corr_noise >> SUM_i [sqrt N^{-1}_{\nui} x gauss_{i}])
### ---- (4) > 'alms' are computed from map_sum
### ---- (5) > beam convolution is performed (at main_band level)
### ---- (6) > CMB terms are computed from alms and spec2data (at main_band level, w/ cmb = .true.):    
### ----          ! Convert from model units to antenna units to map units (+ gain)
### ----          ! For example, if outtype_ == 'uk_cmb'
### ----          spec2data = (1.d0 / bp(band)%a2t) * bp(band)%a2t * bp(band)%gain
### ---- (7) > Template terms are computed (at main_band level)
### ----          v1%temp_amp(i,map_id) = sum(fg_temp(:,:,i) * map_sum)
### ---- (8) > Pixel foreground part
### ----          v1%fg_amp(pixels,:,i) = fg_pix_spec_response(:,:,i) * map_sum
### ---- (9) > mpi_reduce:
### ----          v2%cmb_amp  = SUM_i v1%cmb_amp_{i}
### ----          v2%fg_amp   = SUM_i v1%fg_amp_{i}
### ----          v2%temp_amp = SUM_i v1%temp_amp_{i}
### ----
### ----
### ++++ RHS EQUATIONs: 
### ++++ (0.1) >>  map_sum = N^-1 (r + n)
### ++++ where:
### ---- r: residual (OR residuals_fcn)
### ---- n: gaussian noise realization (OR 'numband' noise realizations)
### ---- N: noise covariance (OR 'main_band' line of the full block matrix)
### ----
### ++++ (0.2) >>  alms = B FT(map_sum)
### ++++ where:
### ---- FT: Fourier Transform-ish > Spherical harmonics decomposition
### ---- B: Beam convolution at main_band (KEPT AT MAIN_BAND)
### ----
### ++++ (0.3.1) >> v1%cmb_amp = spec2data(map_id, cmb=.true.) * alms * npix/(4*pi)  |
### ++++ (0.3.2) >> v1%temp_amp(i,map_id) = sum(fg_temp(:,:,i) * map_sum)            | > type(genvec) v1  >>  v2 = SUM_i v1_{i}
### ++++ (0.3.3) >> v1%fg_amp(pixels,:,i) = fg_pix_spec_response(:,:,i) * map_sum    |
### ----
### ++++ (1.1) >> rhs%cmb_amp  = (v2%cmb_amp * S^{1/2}) + n
### ++++ (1.2) >> rhs%temp_amp = v2%temp_amp
### ++++ (1.3) >> rhs%fg_amp   = v2%fg_amp
### ++++ where:
### ---- S: cls covariance
### ----
### ++++ CGD PRECONDITIONING EQUATIONs
### ++++ Variables:
### ----    b = rhs; x_out = s_i
### ----    my_At_invN_A     !! (numcomp,nmaps)
### ----    At_invN_A_sum    !! (numcomp,nmaps)
### ----    A_diagonal       !! (nmaps, nmaps, 1:numcomp)
### ----    A_lowl2          !! (numcomp_block, numcomp_block)
### ----    A_lowl_template  !! (numcomp_block, numcomp_block) TEMPLATE from trim(chain_dir) // '/precond_mat.unf'
### ----    my_M_fg_pix      !! (num_fg_signal, num_fg_signal, 0:npix-1, nmaps) 
### ----    M_fg_pix_sum     !! (num_fg_signal, num_fg_signal, 0:npix-1, nmaps) 
### ----    inv_N            !! (nmaps)
### ----
### ---- (2.1) >> At_invN_A_sum = SUM_i [B_i^2 inv_N_diag_{\nui}]  !! ALREADY LIKE THIS.
### ----                                                           !! It can also be left like this since it's just a preconditioning.
### ----
### ----       !!!! Other than the next power-spectrum operations, At_invN_A_sum is used in the CG initialization, in 'comm_cgd_mod'
### ----       !!!! at line 136: 'call compute_invM_u(r, d)'. Here r is the difference between two rhs-like terms, which have been
### ----       !!!! generalized:
### ----       !!!! FROM 'compute_invM_u' in 'comm_cgd_precond_mod.f90', line 32
### ----       !!!! >> ! Precondition the high-l CMB components with diagonal preconditioner
### ----       !!!! >> invM_u%cmb_amp(ind,:) = matmul(A_diagonal(:,:,ind), u%cmb_amp(ind,:))
### ----       !!!! >> ...
### ----       !!!! >> ! Precondition the low-l CMB and template coefficients
### ----       !!!! >> call DPOTRS('u', n, nrhs, A_lowl2, n, int_u, n, info)
### ----       !!!! >> ...
### ----       !!!! >> if (sample_fg_pix) then
### ----       !!!! >> invM_u%fg_amp(i,j,:) = matmul(M_fg_pix(:,:,i,j), u%fg_amp(i,j,:))   !!! BUT 'M_fg_pix' HAS BEEN GENERALIZED
### ----                                                                                   !!! (see below)
### ----       
### ---- (2.2.1) >> A_diagonal(i,i,ind) = At_invN_A_sum(i,ind)
### ---- (2.2.2) >> A_diagonal(:,:,ind) = S^{1/2}.T(:,:,l)  A_diagonal(:,:,ind)  S^{1/2}(:,:,l)
### ---- (2.2.3) >> A_diagonal(:,:,ind) = invert_matrix(1.d0 + A_diagonal(:,:,ind))
### ---- ... stuff with A_lowl2





    
commander.f90:           .> call sample_signal_component(iter, precond_type, s_i, stat) ! BUG HERE
comm_signal_mod.f90:     .>   subroutine sample_signal_component(iter, precond_type, s_coeff, stat)
                         .>     ...
                         .>     call compute_rhs_product(.true., .true., .true., rhs)
comm_mp_mod.f90:         .>       subroutine compute_rhs_product(add_wf, add_S_omega, add_N_omega, rhs, fluct)
                         .>         ...
                         .>         call compute_signal_rhs(add_wf, add_S_omega, add_N_omega, rhs, fluct)
comm_cgd_matmul_mod.f90: .>           subroutine compute_signal_rhs(add_wf_in, add_S_omega_in, add_N_omega_in, rhs, fluct)
                         M>             integer(i4b) :: i, j, k, l, m, ierr, band_iter
                         A>             real(dp), allocatable, dimension(:,:)   :: map_sum_dummy_fcn
                         .>             ...
                      **** ADDED PROCEDURE ****
                         *>             if (freq_corr_noise) allocate(map_sum_dummy_fcn(0:map_size-1, nmaps))
                         *>
                         *>             if (add_wf) then
                         *>                if (.not. freq_corr_noise) then
                         *>                   call multiply_by_inv_N(residual, map_sum)
                         *>                else
                         *>                   map_sum = 0.d0
                         *>                   do band_iter = 1, numband
                         *>                      if (trim(noise_format) == 'rms') then
                         *>                         call initialize_invN_rms_fcn(band_iter)
                         *>                      else if (trim(noise_format) == 'dense_matrix') then
                         *>                         call initialize_invN_dense_fcn(map_id, band_iter) 
                         *>                      end if
                         *>                      call multiply_by_inv_N(residuals_fcn(band_iter,:,:), map_sum_dummy_fcn)
                         *>                      map_sum = map_sum + map_sum_dummy_fcn
                         *>                   end do
                         *>                end if
                         *>             else
                         *>                map_sum = 0.d0
                         *>             end if  
                         *>            
                      **** ADDED PROCEDURE ****
                         *>             if (.not. trim(operation) == 'optimize' .and. add_N_omega) then
                         *>                ! Draw the random field in pixel space
                         *>                if (.not. freq_corr_noise) then
                         *>                   do i = 1, nmaps
                         *>                      do j = 0, map_size-1
                         *>                         eta(j,i)  = rand_gauss(rng_handle)
                         *>                      end do
                         *>                   end do
                         *>                   call multiply_by_sqrt_inv_N(eta)
                         *>                   map_sum = map_sum + eta
                         *>                else
                         *>                   do band_iter = 1, numband
                         *>                      do i = 1, nmaps
                         *>                         do j = 0, map_size-1
                         *>                            eta(j,i)  = rand_gauss(rng_handle)
                         *>                         end do
                         *>                      end do
                         *>                      if (trim(noise_format) == 'rms') then
                         *>                         call initialize_invN_rms_fcn(band_iter)
                         *>                      else if (trim(noise_format) == 'dense_matrix') then
                         *>                         call initialize_invN_dense_fcn(map_id, band_iter) 
                         *>                      end if
                         *>                      call multiply_by_sqrt_inv_N(eta)  
                         *>                      map_sum = map_sum + eta
                         *>                   end do
                         *>                end if
                         *>             end if
                         *>
                         .>             ...
                         .>             ! Add template terms; only outside mask
                         .>             if (mask_state == OUTSIDE_MASK .and. sample_temp_coeffs) then
                         .>                do i = 1, num_fg_temp
                         M>                   if (.not. fix_temp(i,map_id)) then
                         A>                      if (.not. freq_corr_noise) then
                         M>                         v1%temp_amp(i,map_id) = sum(fg_temp(:,:,i) * map_sum)
                         A>                      else
                         A>                         v1%temp_amp(i,map_id) = sum(fg_temps_fcn(map_id,:,:,i) * map_sum)
                         A>                      end if
                         A>                   end if
                         .>                end do
                         .>             end if                         
                         .>
                         .>             ! The pixel foreground part
                         .>             do i = 1, num_fg_signal
                         .>                if (fg_components(i)%enforce_positive_amplitude) cycle
                         .>                if (.not. enforce_zero_cl .and. trim(fg_components(i)%type) == 'cmb') cycle
                         A>                if (.not. freq_corr_noise) then
                         M>                   v1%fg_amp(pixels,:,i) = fg_pix_spec_response(:,:,i) * map_sum
                         A>                else
                         A>                    v1%fg_amp(pixels,:,i) = fg_pix_spec_responses_fcn(map_id,:,:,i) * map_sum
                         A>                end if
                         .>             end do
                         .>             ...
                         A>             if (freq_corr_noise) deallocate(map_sum_dummy_fcn)
                         .>             ...
                         .>           end subroutine compute_signal_rhs
                         
comm_signal_mod.f90:     .>     call draw_constrained_realization_by_CG(precond_type, rhs, s_coeff, stat)
comm_cgd_mod.f90:        .>        subroutine draw_constrained_realization_by_CG(precond_type, b, x_out, stat, init)
                         .>          ...
                         .>          call init_precond(precond_type)
comm_mp_mod.f90:         .>             subroutine init_precond(precond_type)
                         .>               ...
                         .>               call initialize_preconditioner(precond_type)
comm_cgd_precond_mod.f90:.>                  subroutine initialize_preconditioner(precond_type_in) 
                         M>                    integer(i4b)     :: i, j, k, l, m, l1, l2, m1, m2, n, ii, jj, kk, ll, q, band_iter
                         .>                    ...
                         A>                       ! Compute the diagonal part
                         A>                       if (.not. freq_corr_noise) then
                         M>                          my_At_invN_A = inv_N_diag(:,:,mask_state)
                         A>                       else
                         A>                          my_At_invN_A = inv_Ns_diag_fcn(map_id,:,:,mask_state)
                         A>                       end if  
                         .>                    ...
                      **** ADDED PROCEDURE ****
                         *>                    ! Set up the pixel foreground preconditioner
                         *>                    if (sample_fg_pix) then
                         *>                
                         *>                       allocate(my_M_fg_pix(num_fg_signal, num_fg_signal, 0:npix-1, nmaps)) 
                         *>                       allocate(M_fg_pix_sum(num_fg_signal, num_fg_signal, 0:npix-1, nmaps)) 
                         *>                       allocate(inv_N(nmaps))
                         *>                       
                         *>                       if (freq_corr_noise) call initialize_invN_rms_fcn(map_id)
                         *>                       my_M_fg_pix = 0.d0
                         *>                       do k = 1, num_fg_signal
                         *>                          if (fg_components(k)%enforce_positive_amplitude) cycle
                         *>                          do l = 1, num_fg_signal
                         *>                             if (fg_components(l)%enforce_positive_amplitude) cycle
                         *>                             if (freq_corr_noise) then
                         *>                                do i = 0, map_size-1
                         *>                                   call get_inv_N_sub_matrix(map_id, mask_state, i, inv_N)
                         *>                                   do j = 1, nmaps
                         *>                                      my_M_fg_pix(k,l,pixels(i),j) = fg_pix_spec_responses_fcn(map_id,i,j,k) * &
                         *>                                           & inv_N(j) * fg_pix_spec_responses_fcn(map_id,i,j,l)
                         *>                                   end do
                         *>                                end do
                         *>                             else
                         *>                                do i = 0, map_size-1
                         *>                                   call get_inv_N_sub_matrix(map_id, mask_state, i, inv_N)
                         *>                                   do j = 1, nmaps
                         *>                                      my_M_fg_pix(k,l,pixels(i),j) = fg_pix_spec_response(i,j,k) * &
                         *>                                           & inv_N(j) * fg_pix_spec_response(i,j,l)
                         *>                                   end do
                         *>                                end do
                         *>                             end if
                         *>                          end do
                         *>                       end do
                         *>                       deallocate(inv_N)
                         *>                
                         *>                       call mpi_reduce(my_M_fg_pix, M_fg_pix_sum, size(my_M_fg_pix), &
                         *>                            & MPI_DOUBLE_PRECISION, MPI_SUM, root, comm_chain, ierr)           
                         *>                
                         *>                    ...
                         .>                    end if
                         .>                
                         .>                  end subroutine initialize_preconditioner

commander.f90:   A> if (.not. freq_corr_noise) then
                 M>    call enforce_pos_amps(chain_dir, residuals_lowres, inv_N_scaled, &
                 M>         & s_i%fg_amp, fg_param_map, iter==1)
                 A> else
                 A>    call enforce_pos_amps(chain_dir, residuals_lowres, inv_N_scaled, &
                 A>         & s_i%fg_amp, fg_param_map, iter==1, inv_Ns_scaled_fcn)
                 A> end if
comm_mp_mod.f90: M>   subroutine enforce_pos_amps(chaindir, residuals, inv_N_noise, fg_amp, index_map, burnin, inv_Ns_noise)
                 A>     real(dp), dimension(1:,0:,1:,1:), intent(in), optional :: inv_Ns_noise
                 .>     ...
                 A>    if (present(inv_Ns_noise)) then
                 A>       call enforce_pos_amp(chaindir, residuals, inv_N_noise, fg_amp, index_map, burnin, inv_Ns_noise)
                 A>    else
                 M>       call enforce_pos_amp(chaindir, residuals, inv_N_noise, fg_amp, index_map, burnin)
                 A>    end if                
comm_fg_mod.f90: M>     subroutine enforce_pos_amp(chaindir, residuals_in, inv_N_in, fg_amp, fg_param_map_in, doburnin, inv_Ns_in_fcn)
                 A>       real(dp), dimension(1:,0:,1:,1:), intent(in),    optional :: inv_Ns_in_fcn
                 A>       integer(i4b) :: band_iter
                 A>       real(dp)     :: contraction_fcn
                 A>       real(dp), allocatable, dimension(:,:,:,:) :: inv_N_fcn
                 .>       ...
                 A>       if (freq_corr_noise .and. present(inv_Ns_in_fcn)) allocate(inv_N_fcn(numband,0:npix-1,nmaps,numband))
                 A>          if (freq_corr_noise .and. present(inv_Ns_in_fcn)) inv_N_fcn = inv_Ns_in_fcn
                 .>       ...
                 .>       do j = 1, numband
                 A>          if (.not. freq_corr_noise) then
                 M>             inv_N_local(j,j) = inv_N(i,1,j)
                 A>          else
                 A>             do band_iter = 1, numband
                 A>                inv_N_local(band_iter,j) = inv_N_fcn(band_iter,i,1,j)
                 A>             end do
                 A>          end if
                 A>       end do
                 .>       ...
                 M>       chisq0 = 0.d0
                 M>       do j = 1, numband
                 A>          if (.not. freq_corr_noise) then
                 M>             chisq0 = chisq0 + (residuals(i,1,j)-sum(M(j,:)*p(:,1)))**2 * inv_N(i,1,j)
                 A>          else
                 A>             contraction_fcn = 0.d0
                 A>             do band_iter = 1, numband
                 A>                contraction_fcn = (residuals(i,1,band_iter)-sum(M(band_iter,:)*p(:,1))) * inv_N_fcn(band_iter,i,1,j)
                 A>             end do
                 A>             chisq0 = chisq0 + (residuals(i,1,j)-sum(M(j,:)*p(:,1))) * contraction_fcn
                 A>          end if
                 M>       end do
                 .>       ...
                 M>       chisq = 0.d0
                 M>       do j = 1, numband
                 A>          if (.not. freq_corr_noise) then
                 M>             chisq = chisq + (residuals(i,1,j)-sum(M(j,:)*p(:,1)))**2 * inv_N(i,1,j)
                 A>          else
                 A>             contraction_fcn = 0.d0
                 A>             do band_iter = 1, numband
                 A>                contraction_fcn = (residuals(i,1,band_iter)-sum(M(band_iter,:)*p(:,1))) * inv_N_fcn(band_iter,i,1,j)
                 A>             end do
                 A>             chisq = chisq + (residuals(i,1,j)-sum(M(j,:)*p(:,1))) * contraction_fcn
                 A>          end if
                 M>       end do
                 .>       ...
                 A>       if (freq_corr_noise) deallocate(inv_N_fcn)
                 .>     end subroutine enforce_pos_amp



#####################################
###### SAMPLE SPECTRAL INDICES ######
#####################################

commander.f90:   A> if (.not. freq_corr_noise) then
                 M>    call sample_spectral_param_map(s_i, residuals_lowres, inv_N_scaled, &
                 M>         & fg_amp_lowres, fg_param_map, stat)
                 A> else
                 A>    call sample_spectral_param_map(s_i, residuals_lowres, inv_N_scaled, &
                 A>         & fg_amp_lowres, fg_param_map, stat, inv_Ns_scaled_fcn)
                 A> end if
comm_mp_mod.f90: M>    subroutine sample_spectral_param_map(s, residuals, inv_N_noise, fg_amp, index_map, stat, inv_Ns_noise)
                 A>      real(dp), dimension(1:,0:,1:,1:), intent(in), optional :: inv_Ns_noise
                 .>      ...
                 A>     if (present(inv_Ns_noise)) then
                 A>        call sample_fg_pix_response_map(s, residuals, inv_N_noise, fg_amp, index_map, stat, inv_Ns_noise)
                 A>     else
                 M>        call sample_fg_pix_response_map(s, residuals, inv_N_noise, fg_amp, index_map, stat)
                 A>     end if                
comm_fg_mod.f90: M>        subroutine sample_fg_pix_response_map(s, residuals_in, inv_N_in, fg_amp_in, fg_param_map, stat, inv_Ns_in_fcn)
                 A>          real(dp), dimension(1:,0:,1:,1:), intent(in),    optional :: inv_Ns_in_fcn
                 A>          integer(i4b) :: band_iter
                 A>          real(dp)     :: contraction_fcn
                 A>          real(dp), allocatable, dimension(:,:,:,:) :: inv_N_fcn
                 .>          ...
                 A>          if (freq_corr_noise) allocate(inv_N_fcn(numband,0:npix-1,nmaps,numband))
                 A>             if (freq_corr_noise) inv_N_fcn = inv_Ns_in_fcn
                 .>          ...
                 A>          if (.not. freq_corr_noise) then
                 M>             call sample_spec_index_single_region(residuals, inv_N, fg_amp, &
                 M>                  & fg_components(i)%indregs(j)%regions(q), p, j, i, par_prop, par_smooth,mystat, &
                 M>                  & chisq_in=chisq_in, chisq_out=chisq_out)
                 A>          else
                 A>             call sample_spec_index_single_region(residuals, inv_N, fg_amp, &
                 A>                  & fg_components(i)%indregs(j)%regions(q), p, j, i, par_prop, par_smooth,mystat, &
                 A>                  & chisq_in=chisq_in, chisq_out=chisq_out, inv_Ns_rms_fcn=inv_N_fcn)
                 A>          end if
comm_fg_mod.f90: A>             real(dp),        allocatable, dimension(:,:,:), private :: invN_regs_fcn
                 .>             ...
                 M>             subroutine sample_spec_index_single_region(data, inv_N_rms, amp, region, p, p_local, comp, par_map, &
                                   & par_smooth, stat, chisq_in, chisq_out, inv_Ns_rms_fcn)
                 A>               real(dp), dimension(1:,0:,1:,1:), intent(in),  optional :: inv_Ns_rms_fcn
                 M>               integer(i4b)     :: i, j, k, n, pix, s, status, ind(1), band_iter
                 .>               ...
                 A>               if (freq_corr_noise .and. present(inv_Ns_rms_fcn)) allocate(invN_regs_fcn(numband,npix_reg,numband))
              **** ADDED PROCEDURE ****   
                 *>                  ! Set up inverse covariance
                 *>                  ...
                 *>                  do j = 1, numband
                 *>                     invN_reg(i,j) = inv_N_rms(pix,s,j)
                 *>                     if (freq_corr_noise) then
                 *>                        do band_iter = 1, numband
                 *>                           invN_regs_fcn(band_iter,i,j) = inv_Ns_rms_fcn(band_iter,pix,s,j)
                 *>                        end do
                 *>                     end if
                 *>                  end do
                 *>                  if (fg_components(comp)%indmask(pix,s) < 0.5d0) then
                 *>                     invN_reg(i,:) = 0.d0
                 *>                     if (freq_corr_noise) invN_regs_fcn(:,i,:) = 0.d0
                 *>                  end if
                 *>               end do
                 *>                   
                 *>               if (sum(abs(invN_reg)) == 0.d0) then
                 *>                  ! No data available; leave unchanged
                 *>                  deallocate(d_reg, amp_reg, invN_reg, s_reg, fg_par_reg, w_reg, pix_reg, inc_band)
                 *>                  if (freq_corr_noise) deallocate(invN_regs_fcn)
                 *>                  return
                 *>               end if
                 .>               ...
                 .>                  if (present(chisq_in)) chisq_in = -2.d0*lnL_specind_ARS(par_old)
comm_fg_mod.f90: .>                     function lnL_specind_ARS(x)
                 M>                        integer(i4b) :: i, j, n, band_iter
                 A>                        real(dp)     :: contraction_fcn, f_rhs
                 A>                        real(dp), allocatable, dimension(:,:) :: df_dummy_fcn
                 .>                        ...
                 A>                        if (.not. freq_corr_noise) then
                 M>                           f = d_reg(i,j) - amp_reg(i) * get_effective_fg_spectrum(fg_components(comp_reg), &
                 M>                                & j, par(1:n), pixel=pix_reg(i,1), pol=pix_reg(i,2))
                 M>                           lnL = lnL - 0.5d0 * f * invN_reg(i,j) * f
                 A>                        else
                 A>                           contraction_fcn = 0.d0
                 A>                           do band_iter = 1, numband
                 A>                              f_rhs = d_reg(i,band_iter) - amp_reg(i) * get_effective_fg_spectrum(fg_components(comp_reg), &
                 A>                                       & band_iter, par(1:n), pixel=pix_reg(i,1), pol=pix_reg(i,2))
                 A>                              contraction_fcn = contraction_fcn + invN_regs_fcn(band_iter,i,j) * f_rhs
                 A>                           end do
                 A>                           lnL = lnL - 0.5d0 * f * contraction_fcn
                 A>                        end if                 
                 .>                        ...
                 .>                        ! Compute Jeffreys prior
                 .>                        if (.false. .and. jeffreys) then     !!!
                 A>                           if (.not. freq_corr_noise) then
                 M>                              lnL_jeffreys = log(sqrt(sum(df * invN_reg * df)))
                 A>                           else
                 A>                              df_dummy_fcn = 0.d0
                 A>                              do band_iter = 1, numband
                 A>                                 df_dummy_fcn = df_dummy_fcn + invN_regs_fcn(band_iter,:,:) * df
                 A>                              end do
                 A>                              lnL_jeffreys = log(sqrt(sum(df * df_dummy_fcn)))
                 A>                           end if
                 .>                        else
                 .>                           lnL_jeffreys = 0.d0
                 .>                        end if  
                 .>                        ...
                 .>                     end function lnL_specind_ARS
comm_fg_mod.f90: .>               ...   
                 A>               if (freq_corr_noise) deallocate(invN_regs_fcn)
                 .>             end subroutine sample_spec_index_single_region                
comm_fg_mod.f90: .>          ...
                 A>          if (.not. freq_corr_noise) then
                 M>             call sample_spec_index_single_region(residuals, inv_N, fg_amp, &
                 M>                  & fg_components(i)%indregs(j)%regions(q), p, j, i, par_prop, par_smooth, &
                 M>                  & mystat, chisq_in=chisq_in, chisq_out=chisq_out)
                 A>          else
                 A>             call sample_spec_index_single_region(residuals, inv_N, fg_amp, &
                 A>                  & fg_components(i)%indregs(j)%regions(q), p, j, i, par_prop, par_smooth, &
                 A>                  & mystat, chisq_in=chisq_in, chisq_out=chisq_out, inv_Ns_rms_fcn=inv_N_fcn)
                 A>          end if
                 .>          ...
                 .>          call compute_total_chisq(map_id, s=s, index_map=par_smooth, chisq_fullsky=chisq0)
comm_chisq_mod.f90: .>          subroutine compute_total_chisq(map_id, s, output_stats, index_map, chisq_map, chisq_highlat, &
                    .>               & chisq_fullsky, chisq_rms, chisq_band, nu_band, chisq_band_fullsky, chain, iter)
                    M>            integer(i4b) :: i, j, k, l, m, p, ierr, c, testpix(4), band_iter 
                    A>            real(dp),     allocatable, dimension(:,:,:)   :: my_signals_fcn
                    A>            real(dp),     allocatable, dimension(:,:)   :: invN_residual1_dummy_fcn, invN_residual2_dummy_fcn
                    A>            real(dp),     allocatable, dimension(:,:,:) :: residuals_fcn_local
                    .>            ...
                    A>            if (.not. freq_corr_noise) then
                    M>               allocate(my_signal(0:map_size-1,nmaps))
                    M>               allocate(residual(0:map_size-1,nmaps))
                    A>            else
                    A>               allocate(my_signals_fcn(numband,0:map_size-1,nmaps))
                    A>               allocate(residuals_fcn_local(numband,0:map_size-1,nmaps))
                    A>               allocate(invN_residual1_dummy_fcn(0:map_size-1,nmaps))
                    A>               allocate(invN_residual2_dummy_fcn(0:map_size-1,nmaps))
                    A>            end if
                 **** ADDED PROCEDURE ****   
                    *>            ! Compute the CMB part
                    *>            if (.not. freq_corr_noise) then
                    *>               my_signal = 0.d0
                    *>               if (.not. enforce_zero_cl) then
                    *>                  if (myid_alms == root) then
                    *>                     allocate(alms_work(numcomp, nmaps))
                    *>                     if (myid_data == root) alms_work = s%cmb_amp
                    *>                     call mpi_bcast(alms_work, size(alms_work), MPI_DOUBLE_PRECISION, root, comm_data, ierr)
                    *>                     call multiply_with_beam(alms_work)
                    *>                     call convert_harmonic_to_real_space(my_signal, alms_work)
                    *>                     deallocate(alms_work)
                    *>                  else
                    *>                     call convert_harmonic_to_real_space(my_signal)
                    *>                  end if
                    *>                  my_signal = my_signal * spec2data(map_id, cmb=.true.)
                    *>                  where (.not. mask)
                    *>                     my_signal = 0.d0
                    *>                  end where
                    *>               end if
                    *>            else
                    *>               my_signals_fcn = 0.d0
                    *>               if (.not. enforce_zero_cl) then
                    *>                  do band_iter = 1, numband
                    *>                     if (myid_alms == root) then
                    *>                        allocate(alms_work(numcomp, nmaps))
                    *>                        if (myid_data == root) alms_work = s%cmb_amp
                    *>                        if (band_iter == map_id) then
                    *>                           call mpi_bcast(alms_work, size(alms_work), MPI_DOUBLE_PRECISION, root, comm_data, ierr)
                    *>                        end if
                    *>                        call multiply_with_beam(alms_work, band_id_in=band_iter)
                    *>                        call convert_harmonic_to_real_space(my_signals_fcn(band_iter,:,:), alms_work)
                    *>                     else
                    *>                        call convert_harmonic_to_real_space(my_signals_fcn(band_iter,:,:))   !!!
                    *>                     end if
                    *>                     my_signals_fcn(band_iter,:,:) = my_signals_fcn(band_iter,:,:) * spec2data(band_iter, cmb=.true.)
                    *>                     where (.not. mask)
                    *>                        my_signals_fcn(band_iter,:,:) = 0.d0
                    *>                     end where
                    *>                  end do
                    *>               end if
                    *>            end if
                    .>            ...
                    A>                  if (.not. freq_corr_noise) then
                    M>                     my_signal = my_signal + my_coeff(j,map_id) * fg_temp(:,:,j)
                    A>                  else
                    A>                     do band_iter = 1, numband
                    A>                        my_signals_fcn(band_iter,:,:) = my_signals_fcn(band_iter,:,:) + my_coeff(j,band_iter) * fg_temps_fcn(band_iter,:,:,j)
                    A>                     end do
                    A>                  end if     
                    .>            ...
                 **** ADDED PROCEDURE ****               
                    *>                        if (.not. freq_corr_noise) then
                    *>                           if (use_index_map) then
                    *>                              call reorder_fg_params(ind_map(pixels(i),:,:), fg_par)
                    *>                              f = get_effective_fg_spectrum(fg_components(k), map_id, fg_par%comp(k)%p(j,:), &
                    *>                                   & pixel=pixels(i), pol=j)
                    *>                           else
                    *>                              f = fg_pix_spec_response(i,j,k)
                    *>                           end if
                    *>                           my_signal(i,j) = my_signal(i,j) + f * fg_amp(pixels(i),j,k)
                    *>                        else
                    *>                           do band_iter = 1, numband
                    *>                              if (use_index_map) then
                    *>                                 call reorder_fg_params(ind_map(pixels(i),:,:), fg_par)
                    *>                                 f = get_effective_fg_spectrum(fg_components(k), band_iter, fg_par%comp(k)%p(j,:), &
                    *>                                      & pixel=pixels(i), pol=j)
                    *>                              else
                    *>                                 f = fg_pix_spec_responses_fcn(band_iter,i,j,k)
                    *>                              end if
                    *>                              my_signals_fcn(band_iter,i,j) = my_signals_fcn(band_iter,i,j) + f * fg_amp(pixels(i),j,k)
                    *>                           end do
                    *>                        end if
                    .>            ...
                    A>               if (.not. freq_corr_noise) then
                    M>                  residual(i,:) = cmbmap(i,:) - my_signal(i,:)
                    A>               else
                    A>                  do band_iter = 1, numband
                    A>                     residuals_fcn_local(band_iter,i,:) = cmbmaps_fcn(band_iter,i,:) - my_signals_fcn(band_iter,i,:)
                    A>                  end do
                    A>               end if
                    M>               !residual = residual
                    .>            ...
                 **** ADDED PROCEDURE ****
                    *>            if (.not. freq_corr_noise) then
                    *>               call multiply_by_sqrt_inv_N(residual, invN_residual1)
                    *>               if (sample_inside_mask) then
                    *>                  mask_state = INSIDE_MASK
                    *>                  call multiply_by_sqrt_inv_N(residual, invN_residual2)
                    *>               else
                    *>                  invN_residual2 = 0.d0
                    *>               end if
                    *>            else
                    *>               invN_residual1 = 0.d0
                    *>               invN_residual2 = 0.d0
                    *>               do band_iter = 1, numband
                    *>                  invN_residual1_dummy_fcn = 0.d0
                    *>                  invN_residual2_dummy_fcn = 0.d0
                    *>                  if (trim(noise_format) == 'rms') then
                    *>                     call initialize_invN_rms_fcn(band_iter)
                    *>                  else if (trim(noise_format) == 'dense_matrix') then
                    *>                     call initialize_invN_dense_fcn(map_id, band_iter) 
                    *>                  end if
                    *>                  call multiply_by_inv_N(residuals_fcn_local(band_iter,:,:), invN_residual1_dummy_fcn)
                    *>                  if (sample_inside_mask) then
                    *>                     mask_state = INSIDE_MASK
                    *>                     call multiply_by_inv_N(residuals_fcn_local(band_iter,:,:), invN_residual2_dummy_fcn)
                    *>                  else
                    *>                     invN_residual2_dummy_fcn = 0.d0
                    *>                  end if
                    *>                  invN_residual1 = invN_residual1 + invN_residual1_dummy_fcn
                    *>                  invN_residual2 = invN_residual2 + invN_residual2_dummy_fcn
                    *>               end do
                    *>            end if
                    .>            ...
                 **** ADDED PROCEDURE ****
                    *>            do j = 1, nmaps
                    *>               do i = 0, map_size-1
                    *>        !       my_chisq_map(pixels(i),1) = sum(residual(i,:)*invN_residual1(i,:)) + &
                    *>        !            & sum(residual(i,:)*invN_residual2(i,:))
                    *>                  if (.not. freq_corr_noise) then
                    *>                     my_chisq_map(pixels(i),j) = invN_residual1(i,j)**2 + invN_residual2(i,j)**2
                    *>                  else
                    *>                     my_chisq_map(pixels(i),1) = residuals_fcn_local(map_id,i,j)*invN_residual1(i,j) + &
                    *>                          & residuals_fcn_local(map_id,i,j)*invN_residual2(i,j)
                    *>                  end if
                    *>               end do
                    *>            end do
                    .>            ...
                    A>               if (.not. freq_corr_noise) then
                    M>                  my_chisq_band(map_id) = sum(invN_residual1**2 * procmask)
                    A>               else
                    A>                  my_chisq_band(map_id) = sum(residuals_fcn_local(map_id,:,:)*invN_residual1 * procmask)
                    A>               end if
                    .>            ...
                    A>               if (.not. freq_corr_noise) then
                    M>                  my_chisq_band(map_id) = sum(invN_residual1**2 * procmask) + sum(invN_residual2**2 * procmask)
                    A>               else
                    A>                  my_chisq_band(map_id) = sum(residuals_fcn_local(map_id,:,:)*invN_residual1 * procmask) + &
                    A>                       & sum(residuals_fcn_local(map_id,:,:)*invN_residual2 * procmask)
                    A>               end if
                    .>            ...
                    A>               if (.not. freq_corr_noise) then
                    M>                  outmap(pixels,:) = residual
                    A>               else
                    A>                  outmap(pixels,:) = residuals_fcn_local(map_id,:,:)
                    A>               end if  
                    .>            ...
                    A>               if (.not. freq_corr_noise) then
                    M>                  call mpi_reduce(sum(invN_residual1**2 * procmask), chisq_tot, 1, MPI_DOUBLE_PRECISION, &
                    M>                       & MPI_SUM, root, comm_chain, ierr)
                    A>               else
                    A>                  call mpi_reduce(sum(residuals_fcn_local(map_id,:,:)*invN_residual1 * procmask), chisq_tot, 1, MPI_DOUBLE_PRECISION, &
                    A>                       & MPI_SUM, root, comm_chain, ierr)
                    A>               end if
                    .>            ...
                 **** ADDED PROCEDURE ****
                    *>            ! Compute chisquare defined by RMS if requested
                    *>            if (output_chisq_rms) then
                    *>               if (.not. freq_corr_noise) then
                    *>                  !call multiply_by_inv_N(residual, invN_residual1, N_format='rms')
                    *>                  call multiply_by_sqrt_inv_N(residual, invN_residual1, N_format='rms')
                    *>                  !my_chisq = sum(residual*invN_residual1)
                    *>                  my_chisq = sum(invN_residual1**2 * procmask)
                    *>                  if (sample_inside_mask) then
                    *>                     mask_state = INSIDE_MASK
                    *>                     !call multiply_by_inv_N(residual, invN_residual2, N_format='rms')
                    *>                     call multiply_by_sqrt_inv_N(residual, invN_residual2, N_format='rms')
                    *>                     mask_state = OUTSIDE_MASK
                    *>                     !my_chisq = my_chisq + sum(residual*invN_residual2)
                    *>                     my_chisq = my_chisq + sum(invN_residual2**2 * procmask)
                    *>                  end if
                    *>                  call mpi_reduce(my_chisq, chisq_tot, 1, MPI_DOUBLE_PRECISION, MPI_SUM, root, comm_chain, ierr)
                    *>                  if (myid_chain == root) chisq_rms = chisq_tot
                    *>               else
                    *>                  invN_residual1 = 0.d0
                    *>                  invN_residual2 = 0.d0
                    *>                  do band_iter = 1, numband
                    *>                     invN_residual1_dummy_fcn = 0.d0
                    *>                     invN_residual2_dummy_fcn = 0.d0
                    *>                     call initialize_invN_rms_fcn(band_iter)
                    *>                     call multiply_by_inv_N(residuals_fcn_local(band_iter,:,:), invN_residual1_dummy_fcn, N_format='rms')
                    *>                     invN_residual1 = invN_residual1 + invN_residual1_dummy_fcn
                    *>                  end do 
                    *>                  my_chisq = sum(residuals_fcn_local(map_id,:,:)*invN_residual1 * procmask)
                    *>                  if (sample_inside_mask) then
                    *>                     mask_state = INSIDE_MASK
                    *>                     do band_iter = 1, numband
                    *>                        call initialize_invN_rms_fcn(band_iter)
                    *>                        call multiply_by_inv_N(residuals_fcn_local(band_iter,:,:), invN_residual2_dummy_fcn, N_format='rms')
                    *>                        invN_residual2 = invN_residual2 + invN_residual2_dummy_fcn
                    *>                     end do
                    *>                     mask_state = OUTSIDE_MASK
                    *>                     my_chisq = my_chisq + sum(residuals_fcn_local(map_id,:,:)*invN_residual2 * procmask)
                    *>                  end if
                    *>                  call mpi_reduce(my_chisq, chisq_tot, 1, MPI_DOUBLE_PRECISION, MPI_SUM, root, comm_chain, ierr)
                    *>                  if (myid_chain == root) chisq_rms = chisq_tot
                    *>               end if
                    *>            end if
                    .>            ...
                    A>            if (.not. freq_corr_noise) then
                    M>               deallocate(residual)
                    M>               deallocate(my_signal)
                    A>            else
                    A>               deallocate(residuals_fcn_local)
                    A>               deallocate(invN_residual1_dummy_fcn)
                    A>               deallocate(invN_residual2_dummy_fcn)
                    A>               deallocate(my_signals_fcn)
                    A>            end if                    
                    .>          end subroutine compute_total_chisq
comm_fg_mod.f90: .>          ...
                 A>          if (freq_corr_noise) deallocate(inv_N_fcn)
                 .>        end subroutine sample_fg_pix_response_map



######################################
###### SAMPLE GLOBAL PARAMETERS ######
######################################
                 
commander.f90:           A> if (.not. freq_corr_noise) then
                         M>    call sample_global_fg_par(rng_handle, s_i, residuals_lowres, inv_N_scaled, fg_param_map, stat)
                         A> else
                         A>    call sample_global_fg_par(rng_handle, s_i, residuals_lowres, inv_N_scaled, fg_param_map, stat, inv_Ns_scaled_fcn)
                         A> end if
comm_global_par_mod.f90: M>    subroutine sample_global_fg_par(handle, s, residuals, inv_N, fg_param_map, stat, inv_Ns_fcn)
                         A>      real(dp), dimension(1:,0:,1:,1:), intent(in), optional :: inv_Ns_fcn
                         .>      ...
                         A>      if (present(inv_Ns_fcn)) then
                         A>         call optimize_priors(handle, s, residuals, inv_N, fg_param_map, stat, inv_Ns_fcn)
                         A>      else
                         M>         call optimize_priors(handle, s, residuals, inv_N, fg_param_map, stat)
                         A>      end if  
comm_global_par_mod.f90: M>         subroutine optimize_priors(handle, s, residuals, inv_N, fg_param_map, stat, inv_Ns_fcn)
                         A>           real(dp), dimension(1:,0:,1:,1:), intent(in), optional :: inv_Ns_fcn
                         .>           ...
                         A>           if (present(inv_Ns_fcn)) then
                         A>              call sample_spectral_param_map(s, residuals, inv_N, s%fg_amp, fg_param_map, stat, inv_Ns_fcn)
                         A>           else
                         M>              call sample_spectral_param_map(s, residuals, inv_N, s%fg_amp, fg_param_map, stat)
                         A>           end if          
                         .>           ...
                         A>           if (present(inv_Ns_fcn)) then
                         A>              call enforce_pos_amps(chaindir, residuals, inv_N, s%fg_amp, fg_param_map, .false., inv_Ns_fcn)
                         A>           else
                         M>              call enforce_pos_amps(chaindir, residuals, inv_N, s%fg_amp, fg_param_map, .false.)
                         A>           end if
                         .>           ...
                         .>         end subroutine optimize_priors
                         .>    end subroutine sample_global_fg_par



#######################################
###### SAMPLE CMB POWER SPECTRUM ######
#######################################

> NO FURTHER MODIFICATIONS



############################################
###### SAMPLE INSTRUMENTAL PARAMETERS ######
############################################

commander.f90: A>  if (.not. freq_corr_noise) then
               M>     do j = 1, numband
               M>        inv_N_scaled(:,:,j) = inv_N_lowres(:,:,j) / noiseamp(j)**2
               M>     end do
               A>  else
               A>     do j = 1, numband
               A>        do band_iter = 1, numband
               A>           inv_Ns_scaled_fcn(band_iter:,:,j) = inv_Ns_lowres_fcn(band_iter,:,:,j) / noiseamp(j)**2   !!!
               A>        end do
               A>     end do       
               A>  end if
               .>  ...
               .>  ! Sample gain
               .>  call sample_gains(s_i, chain, iter)
comm_chisq_mod.f90: .>  subroutine sample_gain(handle, map_id, s, chain, iter) 
                    A>    integer(i4b) :: band_iter
                    A>    real(dp),     allocatable, dimension(:,:,:) :: my_signals_fcn
                    A>    real(dp),     allocatable, dimension(:,:,:) :: residuals_fcn_local
                    .>    ...
                    M>    allocate(invN_signal(0:map_size-1,nmaps))
                    A>    if (.not. freq_corr_noise) then
                    M>       allocate(my_signal(0:map_size-1,nmaps))
                    M>       allocate(residual(0:map_size-1,nmaps))
                    A>    else
                    A>       allocate(my_signals_fcn(numband,0:map_size-1,nmaps))
                    A>       allocate(residuals_fcn_local(numband,0:map_size-1,nmaps))
                    A>    end if 
                    .>    ...
                 **** ADDED PROCEDURE ****                              
                    *>    ! Compute residual
                    *>    if (.not. freq_corr_noise) then
                    *>       residual = cmbmap
                    *>    else
                    *>       residuals_fcn_local = cmbmaps_fcn
                    *>    end if
                    *>    if (num_fg_temp > 0) then
                    *>       allocate(my_coeff(num_fg_temp, numband))
                    *>       if (myid_chain == root) my_coeff = s%temp_amp
                    *>       call mpi_bcast(my_coeff, size(my_coeff), MPI_DOUBLE_PRECISION, root, comm_chain, ierr)
                    *>       if (.not. freq_corr_noise) then
                    *>          do j = 1, num_fg_temp
                    *>             residual = residual - my_coeff(j,map_id) * fg_temp(:,:,j)
                    *>          end do
                    *>       else
                    *>          do j = 1, num_fg_temp
                    *>             do band_iter = 1, numband
                    *>                residuals_fcn_local(band_iter,:,:) = residuals_fcn_local(band_iter,:,:) - &
                    *>                    & my_coeff(j,band_iter) * fg_temps_fcn(band_iter,:,:,j)
                    *>             end do
                    *>          end do
                    *>       end if
                    *>       deallocate(my_coeff)
                    *>    end if                  
                 **** ADDED PROCEDURE ****
                    *>    if (.not. freq_corr_noise) then
                    *>       my_signal = 0.d0
                    *>    else
                    *>       my_signals_fcn = 0.d0
                    *>    end if
                    *>    if (sample_fg_pix) then
                    *>       allocate(fg_amp(0:npix-1,nmaps, num_fg_signal))
                    *>       if (myid_chain == root) fg_amp = s%fg_amp
                    *>       call mpi_bcast(fg_amp, size(fg_amp), MPI_DOUBLE_PRECISION, root, comm_chain, ierr)
                    *>       if (.not. freq_corr_noise) then
                    *>          do k = 1, num_fg_signal
                    *>             if (k == bp(map_id)%comp_calib) cycle
                    *>             do j = 1, nmaps
                    *>                do i = 0, map_size-1
                    *>                   my_signal(i,j) = my_signal(i,j) + fg_pix_spec_response(i,j,k) * fg_amp(pixels(i),j,k)
                    *>                end do
                    *>             end do
                    *>          end do
                    *>          if (bp(map_id)%comp_calib > 0) residual = residual - my_signal
                    *>       else
                    *>          do band_iter = 1, numband
                    *>             do k = 1, num_fg_signal
                    *>                if (k == bp(band_iter)%comp_calib) cycle
                    *>                do j = 1, nmaps
                    *>                   do i = 0, map_size-1
                    *>                      my_signals_fcn(band_iter,i,j) = my_signals_fcn(band_iter,i,j) + &
                    *>                          & fg_pix_spec_responses_fcn(band_iter,i,j,k) * fg_amp(pixels(i),j,k)
                    *>                   end do
                    *>                end do
                    *>             end do
                    *>             if (bp(band_iter)%comp_calib > 0) residuals_fcn_local(band_iter,:,:) = residuals_fcn_local(band_iter,:,:) - &
                    *>                                                  & my_signals_fcn(band_iter,:,:)
                    *>          end do
                    *>       end if
                    *>       if (allocated(fg_par%comp)) call deallocate_fg_params(fg_par)
                    *>       deallocate(fg_amp)
                    *>    end if
                 **** ADDED PROCEDURE ****
                    *>    ! Compute sky signal
                    *>    if (.not. freq_corr_noise) then
                    *>       my_signal = 0.d0
                    *>    else
                    *>       my_signals_fcn = 0.d0
                    *>    end if
                    *>    if (freq_corr_noise) my_signals_fcn = 0.d0
                    *>    if (.not. freq_corr_noise) then
                    *>       if (.not. enforce_zero_cl) then
                    *>          if (myid_alms == root) then
                    *>             allocate(alms_work(numcomp, nmaps))
                    *>             if (myid_data == root) alms_work = s%cmb_amp
                    *>             call multiply_with_beam(alms_work)
                    *>             call convert_harmonic_to_real_space(my_signal, alms_work)
                    *>             deallocate(alms_work)
                    *>          else
                    *>             call convert_harmonic_to_real_space(my_signal)
                    *>          end if
                    *>          my_signal = my_signal * spec2data(map_id, cmb=.true.)
                    *>          where (.not. mask)
                    *>             my_signal = 0.d0
                    *>          end where
                    *>       end if
                    *>    else
                    *>       if (.not. enforce_zero_cl) then
                    *>          do band_iter = 1, numband
                    *>             if (myid_alms == root) then
                    *>                allocate(alms_work(numcomp, nmaps))
                    *>                if (myid_data == root) alms_work = s%cmb_amp
                    *>                call multiply_with_beam(alms_work, band_id_in=band_iter)
                    *>                call convert_harmonic_to_real_space(my_signals_fcn(band_iter,:,:), alms_work)
                    *>                deallocate(alms_work)
                    *>             else
                    *>                call convert_harmonic_to_real_space(my_signals_fcn(band_iter,:,:))
                    *>             end if
                    *>             my_signals_fcn(band_iter,:,:) = my_signals_fcn(band_iter,:,:) * spec2data(band_iter, cmb=.true.)
                    *>             where (.not. mask)
                    *>                my_signals_fcn(band_iter,:,:) = 0.d0
                    *>             end where
                    *>          end do
                    *>       end if
                    *>    end if                 
                 **** ADDED PROCEDURE ****
                    *>    if (sample_fg_pix) then
                    *>       allocate(fg_amp(0:npix-1,nmaps, num_fg_signal))
                    *>       if (myid_chain == root) fg_amp = s%fg_amp
                    *>       call mpi_bcast(fg_amp, size(fg_amp), MPI_DOUBLE_PRECISION, root, comm_chain, ierr)
                    *>       if (.not. freq_corr_noise) then
                    *>          do k = 1, num_fg_signal
                    *>             do j = 1, nmaps
                    *>                do i = 0, map_size-1
                    *>                   if (bp(map_id)%comp_calib > 0 .and. k /= bp(map_id)%comp_calib) cycle
                    *>                   if (.not. enforce_zero_cl .and. trim(fg_components(k)%type) == 'cmb' .and. mask(i,j)) cycle
                    *>                   my_signal(i,j) = my_signal(i,j) + fg_pix_spec_response(i,j,k) * fg_amp(pixels(i),j,k)
                    *>                end do
                    *>             end do
                    *>          end do
                    *>       else
                    *>          do band_iter = 1, numband
                    *>             do k = 1, num_fg_signal
                    *>                do j = 1, nmaps
                    *>                   do i = 0, map_size-1
                    *>                      if (bp(band_iter)%comp_calib > 0 .and. k /= bp(band_iter)%comp_calib) cycle
                    *>                      if (.not. enforce_zero_cl .and. trim(fg_components(k)%type) == 'cmb' .and. mask(i,j)) cycle
                    *>                      my_signals_fcn(band_iter,i,j) = my_signals_fcn(band_iter,i,j) + &
                    *>                          & fg_pix_spec_responses_fcn(band_iter,i,j,k) * fg_amp(pixels(i),j,k)
                    *>                   end do
                    *>                end do
                    *>             end do
                    *>          end do
                    *>       end if
                    *>       if (allocated(fg_par%comp)) call deallocate_fg_params(fg_par)
                    *>       deallocate(fg_amp)
                    *>    end if
                 **** ADDED PROCEDURE ****
                    *>    if (.not. freq_corr_noise) then
                    *>       ! Divide by old gain
                    *>       my_signal = my_signal / bp(map_id)%gain
                    *>
                    *>       ! Apply mask
                    *>       my_signal = my_signal * mask_calib * procmask
                    *>       residual  = residual  * mask_calib * procmask
                    *>    else
                    *>       do band_iter = 1, numband
                    *>          ! Divide by old gain
                    *>          my_signals_fcn(band_iter,:,:) = my_signals_fcn(band_iter,:,:) / bp(band_iter)%gain
                    *>
                    *>          ! Apply mask
                    *>          my_signals_fcn(band_iter,:,:) = my_signals_fcn(band_iter,:,:) * mask_calibs_fcn(band_iter,:,:) * procmask
                    *>          residuals_fcn_local(band_iter,:,:)  = residuals_fcn_local(band_iter,:,:)  * mask_calibs_fcn(band_iter,:,:) * procmask
                    *>       end do
                    *>    end if
                    .>    ...
                 **** ADDED PROCEDURE ****
                    *>       ! Compute cross-spectrum
                    *>       if (.not. freq_corr_noise) then
                    *>          call map2alm(nside, lmax+dl_high, lmax+dl_high, my_signal(:,1), alms, [0.d0,0.d0], weights)
                    *>          !alms(:,0:lmin-1,:) = cmplx(0.d0,0.d0)
                    *>          call apodize_alms(alms, lmin, lmax, dl_low, dl_high)
                    *>          call alm2map(nside, lmax+dl_high, lmax+dl_high, alms, my_signal(:,1))
                    *>          call convert_complex_to_real_alms(alms, alms1)
                    *>          call map2alm(nside, lmax+dl_high, lmax+dl_high, residual(:,1), alms, [0.d0,0.d0], weights)
                    *>          !alms(:,0:lmin-1,:) = cmplx(0.d0,0.d0)
                    *>          call apodize_alms(alms, lmin, lmax, dl_low, dl_high)
                    *>          call alm2map(nside, lmax+dl_high, lmax+dl_high, alms, residual(:,1))
                    *>          call convert_complex_to_real_alms(alms, alms2)
                    *>       else
                    *>          call map2alm(nside, lmax+dl_high, lmax+dl_high, my_signals_fcn(map_id,:,1), alms, [0.d0,0.d0], weights)
                    *>          call apodize_alms(alms, lmin, lmax, dl_low, dl_high)
                    *>          call alm2map(nside, lmax+dl_high, lmax+dl_high, alms, my_signals_fcn(map_id,:,1))
                    *>          call convert_complex_to_real_alms(alms, alms1)
                    *>          call map2alm(nside, lmax+dl_high, lmax+dl_high, residuals_fcn_local(map_id,:,1), alms, [0.d0,0.d0], weights)
                    *>          call apodize_alms(alms, lmin, lmax, dl_low, dl_high)
                    *>          call alm2map(nside, lmax+dl_high, lmax+dl_high, alms, residuals_fcn_local(map_id,:,1))
                    *>          call convert_complex_to_real_alms(alms, alms2)
                    *>       end if
                    .>       ...
                    A>             if (.not. freq_corr_noise) then
                    M>                k = 1
                    M>                do i = 1, numval
                    M>                   do j = i+1, numval
                    M>                      slope(k) = (residual(mask2map(i),1)-residual(mask2map(j),1)) / &
                    M>                           & (my_signal(mask2map(i),1)-my_signal(mask2map(j),1))
                    M>                      k        = k+1
                    M>                   end do
                    M>                end do
                    A>             else
                    A>                k = 1
                    A>                do i = 1, numval
                    A>                   do j = i+1, numval
                    A>                      slope(k) = (residuals_fcn_local(map_id,mask2map(i),1)-residuals_fcn_local(map_id,mask2map(j),1)) / &
                    A>                           & (my_signals_fcn(map_id,mask2map(i),1)-my_signals_fcn(map_id,mask2map(j),1))
                    A>                      k        = k+1
                    A>                   end do
                    A>                end do
                    A>             end if    
                    .>    ...
                 **** ADDED PROCEDURE ****                    
                    *>       ! Sample gain
                    *>       invN_signal = 0.d0
                    *>       if (.not. freq_corr_noise) then
                    *>          do j = 1, nmaps
                    *>             do i = 0, map_size-1
                    *>                if (mask_calib(i,j) > 0.5d0) then
                    *>                   invN_signal(i,j) = my_signal(i,j) * sum(invN_rms(i,j,:))   !!!
                    *>                end if
                    *>             end do
                    *>          end do
                    *>       
                    *>          invN_signal = invN_signal * mask_calib   !!!
                    *>          my_sigma = sum(my_signal * invN_signal)
                    *>          my_mu    = sum(residual  * invN_signal)
                    *>       else
                    *>          do band_iter = 1, numband
                    *>             call initialize_invN_rms_fcn(band_iter)
                    *>             do j = 1, nmaps
                    *>                do i = 0, map_size-1
                    *>                   if (mask_calibs_fcn(band_iter,i,j) > 0.5d0) then
                    *>                      invN_signal(i,j) = invN_signal(i,j) + my_signals_fcn(band_iter,i,j) * sum(invN_rms(i,j,:))
                    *>                   end if
                    *>                end do
                    *>             end do
                    *>          end do
                    *>          
                    *>          invN_signal = invN_signal * mask_calib
                    *>          my_sigma = sum(my_signals_fcn(map_id,:,:) * invN_signal)
                    *>          my_mu    = sum(residuals_fcn_local(map_id,:,:)  * invN_signal)
                    *>       end if
                    .>    ...
                    A>       if (.not. freq_corr_noise) then
                    M>          call write_map(trim(chain_dir)//'/gainres_c'//chain_text//'_b'//band//'_k'//&
                    M>               & iter_text // '.fits', residual, comptype='Residual', unit=bp(map_id)%unit, nu_ref=bp(map_id)%nu_c)
                    M>          call write_map(trim(chain_dir)//'/gainsig_c'//chain_text//'_b'//band//'_k'//&
                    M>               & iter_text // '.fits', my_signal, comptype='Signal model', &
                    M>               & unit=bp(map_id)%unit, nu_ref=bp(map_id)%nu_c)
                    A>       else
                    A>          call write_map(trim(chain_dir)//'/gainres_c'//chain_text//'_b'//band//'_k'//&
                    A>               & iter_text // '.fits', residuals_fcn_local(map_id,:,:), comptype='Residual', unit=bp(map_id)%unit, nu_ref=bp(map_id)%nu_c)
                    A>          call write_map(trim(chain_dir)//'/gainsig_c'//chain_text//'_b'//band//'_k'//&
                    A>               & iter_text // '.fits', my_signals_fcn(map_id,:,:), comptype='Signal model', &
                    A>               & unit=bp(map_id)%unit, nu_ref=bp(map_id)%nu_c)
                    A>       end if  
                    .>    ...
                    M>    deallocate(invN_signal, my_gain)
                    A>    if (.not. freq_corr_noise) then
                    M>       deallocate(residual, my_signal)
                    A>    else
                    A>       deallocate(residuals_fcn_local, my_signals_fcn)
                    A>    end if
                    .>  end subroutine sample_gain
                    
commander.f90: .>  ! Sample bandpass errors
               .>  call sample_bandpasses(s_i, fg_param_map, chain, iter)
comm_chisq_mod.f90: .> subroutine sample_bandpass(handle, map_id, s, index_map, chain, iter)
                    .>   ...
                    .>   call compute_bandpass_chisq(bp%delta, chisq0, s, index_map)
comm_chisq_mod.f90: .>      subroutine compute_bandpass_chisq(delta, chisq, s, index_map)
                    .>        ...
                    A>           if (.not. freq_corr_noise) then
                    M>              call update_fg_pix_response_map(map_id, pixels, fg_pix_spec_response, fg_param_map_in = index_map)
                    A>           else
                    A>              call update_fg_pix_response_map(map_id, pixels, fg_pix_spec_response, fg_pix_spec_responses_fcn, fg_param_map_in = index_map)
                    A>           end if
                    A>        ...
                    A>           if (.not. freq_corr_noise) then
                    M>              call update_fg_pix_response_map(map_id, pixels, fg_pix_spec_response)
                    A>           else
                    A>              call update_fg_pix_response_map(map_id, pixels, fg_pix_spec_response, fg_pix_spec_responses_fcn)
                    A>           end if
                    .>        ...
                    .>      end subroutine compute_bandpass_chisq
comm_chisq_mod.f90: .>   ...
                    A>            if (.not. freq_corr_noise) then
                    M>               call update_fg_pix_response_map(map_id, pixels, fg_pix_spec_response, fg_param_map_in = index_map)
                    A>            else
                    A>               call update_fg_pix_response_map(map_id, pixels, fg_pix_spec_response, fg_pix_spec_responses_fcn, fg_param_map_in = index_map)
                    A>            end if
                    .>   ...
                    A>             if (.not. freq_corr_noise) then
                    M>                call update_fg_pix_response_map(map_id, pixels, fg_pix_spec_response)
                    A>             else
                    A>                call update_fg_pix_response_map(map_id, pixels, fg_pix_spec_response, fg_pix_spec_responses_fcn)
                    A>             end if
                    .>   ...
                    A>             if (.not. freq_corr_noise) then
                    M>                call update_fg_pix_response_map(map_id, pixels, fg_pix_spec_response, fg_param_map_in = index_map)
                    A>             else
                    A>                call update_fg_pix_response_map(map_id, pixels, fg_pix_spec_response, fg_pix_spec_responses_fcn, fg_param_map_in = index_map)
                    A>             end if                    
                    .>   ...
                    A>             if (.not. freq_corr_noise) then
                    M>                call update_fg_pix_response_map(map_id, pixels, fg_pix_spec_response)
                    A>             else
                    A>                call update_fg_pix_response_map(map_id, pixels, fg_pix_spec_response, fg_pix_spec_responses_fcn)
                    A>             end if
                    .>   ...
                    .>       if (myid_chain == root) then
                    A>          if (.not. freq_corr_noise) then
                    M>             call update_fg_pix_response_map(map_id, pixels, fg_pix_spec_response, fg_param_map_in = index_map)
                    A>          else
                    A>             call update_fg_pix_response_map(map_id, pixels, fg_pix_spec_response, fg_pix_spec_responses_fcn, fg_param_map_in = index_map)
                    A>          end if
                    .>       else
                    A>          if (.not. freq_corr_noise) then
                    M>             call update_fg_pix_response_map(map_id, pixels, fg_pix_spec_response)
                    A>          else
                    A>             call update_fg_pix_response_map(map_id, pixels, fg_pix_spec_response, fg_pix_spec_responses_fcn)
                    A>          end if
                    .>       end if
                    .>   ...
                    .> end subroutine sample_bandpass
                    
commander.f90: A>          if (.not. freq_corr_noise) then
               M>             call init_ind_by_nonlin_search(residuals_lowres, inv_N_scaled, fg_param_map, s_i%fg_amp)
               A>          else
               A>             call init_ind_by_nonlin_search(residuals_lowres, inv_N_scaled, fg_param_map, s_i%fg_amp, inv_Ns_scaled_fcn)
               A>          end if
               .>    ...



###################################
###### VARIOUS SANITY CHECKS ######
###################################

commander.f90: .> ! Store sample to disk
               .> call output_sample(paramfile, chain, iter, s_i, skip_freq, cl_i, fg_param_map, noiseamp, bp%gain, bp%delta)
commander.f90: .>      subroutine output_sample(paramfile, chain, iter, s_i, skip_freq, cl_i, fg_param_map, &
               .>           & noiseamps, gain, delta)
               .>        ...
               A>              if (.not. freq_corr_noise) then
               M>                 call output_pixel_to_file(object_dir, chain, objname(i), pix(i), iter, &
               M>                      & cmbmaps_lowres(pix(i),:,:), inv_N_scaled(pix(i),:,:), cmb_pix(i,:), &
               M>                      & tempamps, fg_temp_lowres(pix(i),:,:,:), &
               M>                      & s_i%fg_amp(pix(i),:,:), par_smooth(pix(i),:,:), chisq_map(pix(i),1))
               A>              else
               A>                 call output_pixel_to_file(object_dir, chain, objname(i), pix(i), iter, &
               A>                      & cmbmaps_lowres(pix(i),:,:), inv_N_scaled(pix(i),:,:), cmb_pix(i,:), &
               A>                      & tempamps, fg_temp_lowres(pix(i),:,:,:), &
               A>                      & s_i%fg_amp(pix(i),:,:), par_smooth(pix(i),:,:), chisq_map(pix(i),1), &
               A>                      & inv_Ns_scaled_fcn(:,pix(i),:,:))
               A>              end if
commander.f90: M>                    subroutine output_pixel_to_file(chain_dir, chain, objname, pixel, iter, data, invN, cmb_pix, &
               M>                         & temp_amp, fg_temp, fg_amp, fg_param, chisq, invNs_fcn)
               A>                      real(dp),         dimension(:,:,:), intent(in), optional :: invNs_fcn
               M>                      integer(i4b) :: i, j, k, q, unit, band_iter
               .>                      ...
               A>                         if (freq_corr_noise .and. present(invNs_fcn)) then
               A>                            if (all(invNs_fcn(:,j,:) == 0.d0)) cycle
               A>                         else
               M>                            if (all(invN(j,:) == 0.d0)) cycle
               A>                         end if
               .>                         ...
            **** ADDED PROCEDURE ****
               *>                         ! Print out data
               *>                         write(unit,*) '# Data with template corrections:'
               *>                         do i = 1, numband
               *>                            q = i2f(i)
               *>                            if (freq_corr_noise .and. present(invNs_fcn)) then
               *>                               do band_iter = 1, numband
               *>                                  write(unit,*) '## Band_iter = ', band_iter
               *>                                  if (invNs_fcn(band_iter,j,q) > 0.d0) then
               *>                                     f = data(j,q)
               *>                                     do k = 1, size(temp_amp,1)
               *>                                        f = f - temp_amp(k,q) * fg_temp(j,q,k)
               *>                                     end do
               *>                                     scale = spec2data(q, intype='uK_ant', outtype=bp(q)%unit)
               *>                                     write(unit,fmt='(3e16.8)') bp(q)%nu_c/1d9, f/scale, &
               *>                                          & sqrt(1.d0/invNs_fcn(band_iter,j,q))/scale
               *>                                  end if
               *>                               end do
               *>                            else
               *>                               if (invN(j,q) > 0.d0) then
               *>                                  f = data(j,q)
               *>                                  do k = 1, size(temp_amp,1)
               *>                                     f = f - temp_amp(k,q) * fg_temp(j,q,k)
               *>                                  end do
               *>                                  scale = spec2data(q, intype='uK_ant', outtype=bp(q)%unit)
               *>                                  write(unit,fmt='(3e16.8)') bp(q)%nu_c/1d9, f/scale, &
               *>                                       & sqrt(1.d0/invN(j,q))/scale
               *>                               end if
               *>                            end if
               *>                         end do
               *>                         write(unit,*)
            **** ADDED PROCEDURE ****
               *>                         write(unit,*) '# Data without template corrections:'
               *>                         do i = 1, numband
               *>                            q = i2f(i)
               *>                            if (freq_corr_noise .and. present(invNs_fcn)) then
               *>                               do band_iter = 1, numband
               *>                               write(unit,*) '## Band_iter = ', band_iter
               *>                                  if (invNs_fcn(band_iter,j,q) > 0.d0) then
               *>                                     f = data(j,q)
               *>                                     scale = spec2data(q, intype='uK_ant', outtype=bp(q)%unit)
               *>                                     write(unit,fmt='(3e16.8)') bp(q)%nu_c/1d9, f/scale, &
               *>                                          & sqrt(1.d0/invNs_fcn(band_iter,j,q))/scale
               *>                                  end if
               *>                               end do
               *>                            else
               *>                               if (invN(j,q) > 0.d0) then
               *>                                  f = data(j,q)
               *>                                  scale = spec2data(q, intype='uK_ant', outtype=bp(q)%unit)
               *>                                  write(unit,fmt='(3e16.8)') bp(q)%nu_c/1d9, f/scale, &
               *>                                       & sqrt(1.d0/invN(j,q))/scale
               *>                               end if
               *>                            end if
               *>                         end do
               *>                         write(unit,*)
            **** ADDED PROCEDURE ****
               *>                         ! Print out cmb amplitude
               *>                         spec_tot = 0.d0
               *>                         if (cmb_pix(j) /= 0.d0) then
               *>                            write(unit,*) '# CMB with Cls'
               *>                            do i = 1, numband
               *>                               q = i2f(i)
               *>                               if (freq_corr_noise .and. present(invNs_fcn)) then
               *>                                  if (any(invNs_fcn(:,j,q) > 0.d0)) then
               *>                                     f = cmb_pix(j)/bp(q)%a2t
               *>                                     spec_tot(q) = spec_tot(q) + f
               *>                                     if (f > 0.d0) write(unit,fmt='(3e16.8)') bp(q)%nu_c/1d9, f, 0.d0
               *>                                  end if
               *>                               else
               *>                                  if (invN(j,q) > 0.d0) then
               *>                                     f = cmb_pix(j)/bp(q)%a2t
               *>                                     spec_tot(q) = spec_tot(q) + f
               *>                                     if (f > 0.d0) write(unit,fmt='(3e16.8)') bp(q)%nu_c/1d9, f, 0.d0
               *>                                  end if
               *>                               end if
               *>                            end do
               *>                         end if
               *>                         write(unit,*)       
            **** ADDED PROCEDURE ****
               *>                         ! Print out signal components
               *>                         ...
               *>                            do i = 1, numband
               *>                               q = i2f(i)
               *>                               if (freq_corr_noise .and. present(invNs_fcn)) then
               *>                                  if (any(invNs_fcn(:,j,q) > 0.d0)) then
               *>                                     scale = spec2data(q, intype='uK_ant', outtype=bp(q)%unit)
               *>                                     f = get_effective_fg_spectrum(fg_components(k), q, fg_par%comp(k)%p(j,:), &
               *>                                          & pixel=pixel, pol=j) * fg_amp(j,k) / scale
               *>                                     spec_tot(q) = spec_tot(q) + f
               *>                                     if (f /= 0.d0) write(unit,fmt='(3e16.8)') bp(q)%nu_c/1d9, f, 0.d0
               *>                                  end if             else
               *>                                  if (invN(j,q) > 0.d0) then
               *>                                     scale = spec2data(q, intype='uK_ant', outtype=bp(q)%unit)
               *>                                     f = get_effective_fg_spectrum(fg_components(k), q, fg_par%comp(k)%p(j,:), &
               *>                                          & pixel=pixel, pol=j) * fg_amp(j,k) / scale
               *>                                     spec_tot(q) = spec_tot(q) + f
               *>                                     if (f /= 0.d0) write(unit,fmt='(3e16.8)') bp(q)%nu_c/1d9, f, 0.d0
               *>                                  end if
               *>                               end if
               *>                            end do
               .>                         ...
            **** ADDED PROCEDURE ****              
               *>                         ! Print out total signal
               *>                         write(unit,*) '# Total signal component'
               *>                         do i = 1, numband
               *>                            q = i2f(i)
               *>                            if (freq_corr_noise .and. present(invNs_fcn)) then
               *>                               if (any(invNs_fcn(:,j,q) > 0.d0)) then
               *>                                  write(unit,fmt='(3e16.8)') bp(q)%nu_c/1d9, spec_tot(q), 0.d0
               *>                               end if
               *>                            else
               *>                               if (invN(j,q) > 0.d0) then
               *>                                  write(unit,fmt='(3e16.8)') bp(q)%nu_c/1d9, spec_tot(q), 0.d0
               *>                               end if
               *>                            end if
               *>                         end do
               *>                         close(unit)       
               .>                      ...
               .>                    end subroutine output_pixel_to_file
               .>        ...
commander.f90: .>        call output_component_maps(map_id, s_i, chain, iter, chain_dir)            
comm_data_mod.f90: .>       subroutine output_component_map(map_id, s_in, chain_in, iter_in, chain_dir)
                   .>         ...
                   A>               if (.not. freq_corr_noise) then
                   M>                  signal = signal + s%temp_amp(j,map_id) * fg_temp(:,:,j)
                   A>               else
                   A>                  signal = signal + s%temp_amp(j,map_id) * fg_temps_fcn(map_id,:,:,j)
                   A>               end if 
                   .>         ...
                   A>               if (.not. freq_corr_noise) then
                   M>                  signal = signal + s%fg_amp(pixels,:,k) * fg_pix_spec_response(:,:,k)
                   A>               else
                   A>                  signal = signal + s%fg_amp(pixels,:,k) * fg_pix_spec_responses_fcn(map_id,:,:,k)
                   A>               end if
                   .>         ...
                   .>         ! Compute residual
                   A>         if (.not. freq_corr_noise) then
                   M>            signal = cmbmap - signal
                   A>         else
                   A>            signal = cmbmaps_fcn(map_id,:,:) - signal
                   A>         end if  
                   .>         ...
                   A>               if (.not. freq_corr_noise) then
                   M>                  outmap(pixels,:) = s%fg_amp(pixels,:,c) * fg_pix_spec_response(:,:,c) !* ant2data(map_id)
                   A>               else
                   A>                  outmap(pixels,:) = s%fg_amp(pixels,:,c) * fg_pix_spec_responses_fcn(map_id,:,:,c) !* ant2data(map_id)
                   A>               end if
                   .>         ...
                   .>       end subroutine output_component_map
commander.f90: .>        call output_mixing_matrices(map_id, chain, iter, chain_dir)                   
comm_data_mod.f90: .>       subroutine output_mixing_matrix(map_id, chain_in, iter_in, chain_dir)  
                   .>       ...
                   A>          if (.not. freq_corr_noise) then
                   M>             outmap(pixels,:) = fg_pix_spec_response(:,:,i)
                   A>          else
                   A>             outmap(pixels,:) = fg_pix_spec_responses_fcn(map_id,:,:,i)
                   A>          end if       
                   .>       ...
                   .>       end subroutine output_mixing_matrix
               .>        ...
commander.f90: .>        if (output_cross_corr .and. num_fg_comp > 0) call output_signal_correlations(s_i, chisq_map, &
               .>             & chain, iter, chain_dir)
comm_data_mod.f90: .>       subroutine output_signal_correlations(s, chisq_map, chain, iter, chain_dir)
                   .>         ...
                   A>               if (.not. freq_corr_noise) then
                   M>                  alms_cmb(1,l,:) = alms_cmb(1,l,:) * beam(l,1)
                   A>               else
                   A>                  alms_cmb(1,l,:) = alms_cmb(1,l,:) * beams_fcn(map_id,l,1)
                   A>               end if                   
                   .>         ...
                   .>       end subroutine output_signal_correlations
               .>       ... 
commander.f90: .>     end subroutine output_sample


commander.f90: A> if (.not. freq_corr_noise) then
               M>    call output_ml_map(paramfile)
               A> else
               A>    call output_ml_map(paramfile, band_id)
               A> end if



###############################################
###### END OF MAIN COMPUTATIONAL ROUTINE ######*******************************************************************************************
###############################################


######################
###### CLEAN UP ######
######################

####
#### ALREADY PRESENT CLEAN UP ROUTINES
####

commander.f90: .> call clean_up_N_mult_mod
comm_N_mult_mod.f90: .> subroutine clean_up_N_mult_mod                                        !! 
                     .>   implicit none                                                       !! Does nothing: 
                     .>                                                                       !! Could be
                     A>   if (allocated(invN_rms))           deallocate(invN_rms)             !! left
                     A>   if (allocated(sqrt_invN_rms))      deallocate(sqrt_invN_rms)        !! untouched.
                     A>   if (allocated(invN_dense))         deallocate(invN_dense)           !! 
                     A>   if (allocated(sqrt_invN_dense))    deallocate(sqrt_invN_dense)      !! But added
                     A>   if (allocated(invN_pixblock))      deallocate(invN_pixblock)        !! deallocations
                     A>   if (allocated(sqrt_invN_pixblock)) deallocate(sqrt_invN_pixblock)   !! for the
                     A>   if (allocated(invN_dense))         deallocate(invN_dense)           !! sake of
                     A>   if (allocated(mask2map))           deallocate(mask2map)             !! completeness.
                     A>   if (allocated(noiseamp))           deallocate(noiseamp)             !!
                     .>                                                                       !!
                     .> end subroutine clean_up_N_mult_mod                                    !! 

commander.f90: .> call clean_up_S_mult_mod
comm_S_mult_mod.f90: .> subroutine clean_up_S_mult_mod                        !!
                     .>   implicit none                                       !!
                     .>                                                       !!
                     .>   if (allocated(S))          deallocate(S)            !!  Left
                     .>   if (allocated(sqrt_S))     deallocate(sqrt_S)       !!  untouched
                     .>   if (allocated(inv_sqrt_S)) deallocate(inv_sqrt_S)   !!
                     .>                                                       !!
                     .> end subroutine clean_up_S_mult_mod                    !!

commander.f90: .> call cleanup_signal_mod
comm_signal_mod.f90: .> subroutine cleanup_signal_mod                 !!
comm_Cl_sampling_mod.f90: .> call cleanup_Cl_sampling_mod             !! Does nothing:
                          .>   implicit none                          !! left
                          .>                                          !! untouched
                          .> end subroutine cleanup_Cl_sampling_mod   !!

commander.f90: .> call cleanup_mcmc_mod
comm_mcmc_mod.f90: .> subroutine cleanup_mcmc_mod                       !!
                   .>   implicit none                                   !! Does nothing:
                   .>                                                   !! could be
                   A>   if (allocated(cls_prop)) deallocate(cls_prop)   !! left untouched.
                   .>                                                   !! But added deallocation.
                   .> end subroutine cleanup_mcmc_mod                   !!


####
#### ADDED CLEAN UP ROUTINES (just for completeness)
####

commander.f90: A> call cleanup_beam_mod
comm_beam_mod.f90: .> subroutine cleanup_beam_mod
                   .>   implicit none
                   .>    
                   .>   if (allocated(beam))        deallocate(beam)
                   A>   if (allocated(beam_lowres)) deallocate(beam_lowres)
                   A>   if (allocated(beams_fcn))   deallocate(beams_fcn) 
                   .>
                   .> end subroutine cleanup_beam_mod
                   
commander.f90: A> call cleanup_bp_mod
comm_bp_mod.f90: A> subroutine cleanup_bp_mod
                 A>   implicit none
                 A>    
                 A>   if (allocated(bp))  deallocate(bp)
                 A>   if (allocated(i2f)) deallocate(i2f)
                 A>
                 A> end subroutine cleanup_bp_mod
                 
commander.f90: A> call cleanup_precond_mod
comm_cgd_precond_mod.f90: .> subroutine cleanup_precond_mod
                          .>   implicit none
                          .>    
                          .>   if (allocated(A_diagonal))          deallocate(A_diagonal)
                          A>   if (allocated(A_lowl))              deallocate(A_lowl)
                          .>   if (allocated(A_lowl2))             deallocate(A_lowl2)
                          .>   if (allocated(A_lowl_template))     deallocate(A_lowl_template)
                          .>   if (allocated(inv_N_diag))          deallocate(inv_N_diag)
                          .>   if (allocated(inv_N_lowl))          deallocate(inv_N_lowl)
                          .>   if (allocated(M_fg_pix))            deallocate(M_fg_pix)
                          .>
                          .> end subroutine cleanup_precond_mod

commander.f90: A> call cleanup_chisq_mod
comm_chisq_mod.f90: A> subroutine cleanup_chisq_mod
                    A>   implicit none
                    A>    
                    A>   if (allocated(g_gauss))        deallocate(g_gauss)
                    A>   if (allocated(procmask))       deallocate(procmask)
                    A>   if (allocated(procmask_full))  deallocate(procmask_full)
                    A>
                    A> end subroutine cleanup_chisq_mod

commander.f90: A> call cleanup_Cl_util_mod
comm_Cl_util_mod.f90: .> subroutine cleanup_Cl_util_mod
                      .>   implicit none
                      .>    
                      .>   if (allocated(Cl_bins))     deallocate(Cl_bins)
                      .>   if (allocated(Cl_bin_stat)) deallocate(Cl_bin_stat)
                      .>
                      .> end subroutine cleanup_Cl_util_mod

commander.f90: A> call cleanup_data_mod
comm_data_mod.f90: .> subroutine cleanup_data_mod
                   .>   implicit none
                   .>    
                   .>   if (allocated(cmbmap))                    deallocate(cmbmap)
                   .>   if (allocated(signal_map))                deallocate(signal_map)
                   .>   if (allocated(residual))                  deallocate(residual)
                   .>   if (allocated(foreground_map))            deallocate(foreground_map)
                   .>   if (allocated(fg_temp))                   deallocate(fg_temp)
                   .>   if (allocated(mask))                      deallocate(mask)
                   .>   if (allocated(fg_pix_spec_response))      deallocate(fg_pix_spec_response)
                   .>   if (allocated(cmbmaps_lowres))            deallocate(cmbmaps_lowres)
                   .>   if (allocated(inv_N_lowres))              deallocate(inv_N_lowres)
                   .>   if (allocated(inv_N_scaled))              deallocate(inv_N_scaled)
                   .>   if (allocated(residuals_lowres))          deallocate(residuals_lowres)
                   .>   if (allocated(fg_temp_lowres))            deallocate(fg_temp_lowres)
                   .>   if (allocated(mask_calib))                deallocate(mask_calib)
                   .>   deallocate(pixels)
                   A>   if (allocated(tempamp))                   deallocate(tempamp)
                   A>   if (allocated(mask_lowres))               deallocate(mask_lowres)              
                   A>   if (allocated(mask_corr))                 deallocate(mask_corr)             
                   A>   if (allocated(cmbmaps_fcn))               deallocate(cmbmaps_fcn)
                   A>   if (allocated(residuals_fcn))             deallocate(residuals_fcn)
                   A>   if (allocated(fg_temps_fcn))              deallocate(fg_temps_fcn)
                   A>   if (allocated(fg_pix_spec_responses_fcn)) deallocate(fg_pix_spec_responses_fcn)
                   A>   if (allocated(inv_Ns_lowres_fcn))         deallocate(inv_Ns_lowres_fcn)
                   A>   if (allocated(inv_Ns_scaled_fcn))         deallocate(inv_Ns_scaled_fcn)
                   A>   if (allocated(mask_calibs_fcn))           deallocate(mask_calibs_fcn)
                   .>
                   .> end subroutine cleanup_data_mod
                 
commander.f90: A> call cleanup_comm_fg_component_mod
comm_fg_component_mod.f90: .> subroutine cleanup_comm_fg_component_mod
                           .>   implicit none
                           .>    
                           A>   if (allocated(fg_components)) deallocate(fg_components)
                           .>
                           .> end subroutine cleanup_comm_fg_component_mod
                 
commander.f90: A> call cleanup_comm_fg_mod
comm_fg_mod.f90: .> subroutine cleanup_fg_mod
                 .>   implicit none
                 .>    
                 A>   if (allocated(my_residual))    deallocate(my_residual)
                 A>   if (allocated(my_inv_N))       deallocate(my_inv_N)
                 A>   if (allocated(my_inv_Ns_fcn))  deallocate(my_inv_Ns_fcn)
                 A>   if (allocated(all_residuals))  deallocate(all_residuals)
                 A>   if (allocated(all_inv_N))      deallocate(all_inv_N)
                 A>   if (allocated(all_inv_Ns_fcn)) deallocate(all_inv_Ns_fcn)
                 A>   if (allocated(pix_reg))        deallocate(pix_reg)
                 A>   if (allocated(s_reg))          deallocate(s_reg)
                 A>   if (allocated(amp_reg))        deallocate(amp_reg)
                 A>   if (allocated(w_reg))          deallocate(w_reg)
                 A>   if (allocated(scale_reg))      deallocate(scale_reg)
                 A>   if (allocated(d_reg))          deallocate(d_reg)
                 A>   if (allocated(invN_reg))       deallocate(invN_reg)
                 A>   if (allocated(invN_regs_fcn))  deallocate(invN_regs_fcn)
                 A>   if (allocated(x_def))          deallocate(x_def)
                 A>   if (allocated(fg_par_reg))     deallocate(fg_par_reg)
                 A>   if (allocated(p_default))      deallocate(p_default)
                 .>
                 .> end subroutine cleanup_fg_mod
                 
commander.f90: A> call cleanup_genvec_mod                
comm_genvec_mod.f90: A> subroutine cleanup_genvec_mod
                     A>   implicit none
                     A>  
                     A>   if (allocated(fix_temp)) deallocate(fix_temp)
                     A> 
                     A> end subroutine cleanup_genvec_mod
                     
commander.f90: A> call cleanup_global_par_mod               
comm_genvec_mod.f90: A> subroutine cleanup_global_par_mod
                     A>   implicit none
                     A> 
                     A>   if (allocated(index_map_rms)) deallocate(index_map_rms)
                     A>   if (allocated(x_init)) deallocate(x_init)
                     A>
                     A> end subroutine cleanup_global_par_mod

commander.f90: A> call cleanup_noiseamp_mod
comm_noiseamp_mod.f90: A> subroutine cleanup_noiseamp_mod
                       A>   implicit none
                       A>  
                       A>   if (allocated(N_prior)) deallocate(N_prior)
                       A> 
                       A> end subroutine cleanup_noiseamp_mod
               
commander.f90: A> call cleanup_utils
comm_utils.f90: A> subroutine cleanup_utils
                A>   implicit none
                A>  
                A>   if (allocated(plms)) deallocate(plms)
                A> 
                A> end subroutine cleanup_utils

commander.f90: .> ! Clean up arrays
               A> if (allocated(weights))      deallocate(weights)
               A> if (allocated(fg_param_map)) deallocate(fg_param_map)



##########################################################################################################################################
##########################################################################################################################################

- TO CHECK >>  'alms' everywhere (needs to be generalized to all bands?)

##########################################################################################################################################
##########################################################################################################################################

List of new global variables:

integer(i4b) :: band_iter, map_id_fcn
logical(lgt) :: freq_corr_noise
real(dp),     allocatable, dimension(:,:,:)           :: beams_fcn
real(dp),     allocatable, dimension(:),      private :: reg_noises_fcn
real(dp),     allocatable, dimension(:,:,:)           :: cmbmaps_fcn, residuals_fcn
real(dp),     allocatable, dimension(:,:,:)           :: mask_calibs_fcn
real(dp),     allocatable, dimension(:,:,:,:)         :: fg_pix_spec_responses_fcn
real(dp),     allocatable, dimension(:,:,:,:)         :: fg_temps_fcn
real(dp),     allocatable, dimension(:,:,:,:)         :: inv_Ns_lowres_fcn, inv_Ns_scaled_fcn
real(dp),     allocatable, dimension(:,:),    private :: my_inv_Ns_fcn
real(dp),     allocatable, dimension(:,:,:),  private :: all_inv_Ns_fcn
real(dp),     allocatable, dimension(:,:,:),  private :: invN_regs_fcn


##########################################################################################################################################
##########################################################################################################################################

QUESTIONS:
1. line 558:  *> call convert_harmonic_to_real_space(map)  !!! Not cycling on bands, but it need alms.
                                                           !!! Also at line 1828                                                         
1.5 inv_S matrix from cls (always set from random power spectrum or cmb cls, it doesn't seem to be affected by noise correlations)

2. line 1567: *> call get_inv_N_sub_matrix(map_id, mask_state, i, inv_N)  !!!  Only rms in preconditioning

3. 'comm_cgd_mod.f90', line 173: *> call output_maps_from_iteration(32, 64, 0, i, 'chains', x_out%cmb_amp, 420.d0)  !!! Fixed nside 32?

4. line 1752: *> 'if (.false. .and. jeffreys) then'  !!! lnL_jeffreys is never computed

5. 'comm_chisq_mod.f90', line 424: *> ...frac_residual_' // trim(bp(map_id)%label)...  !!! frac = full

6. 'comm_global_par_mod.f90', line 151: *> rms1  = sqrt(sum((mask(:,i)*(map1(:,i)-mu1))**2)/npix)  !!! Divided by N and not N-1
   !!! While, for example:
   !!! 'comm_data_mod.f90', line 1148: *> sigma(j) = sqrt(sum(mask(:,1)*(maps(:,1,j)-mu(j))**2) / (n-1))

7. line 2070:  *> inv_Ns_scaled_fcn(band_iter:,:,j) = inv_Ns_lowres_fcn(band_iter,:,:,j) / noiseamp(j)**2  !!! It should be right to 
                                                                                                           !!! divide each line block
                                                                                                           !!! by the same main_band
                                                                                                           !!! noiseamp value, 
                                                                                                           !!! since this is computed
                                                                                                           !!! to take into account
                                                                                                           !!! correlations

8. line 2299:  *> invN_signal(i,j) = my_signal(i,j) * sum(invN_rms(i,j,:))  !!! The likelihood routine during gain sampling
                                                                            !!! is performed using noise rms only
8.5 line 2304:  *> invN_signal = invN_signal * mask_calib  !!! During the N^-1 s multiplication, contributes are collected from
                                                           !!! secondary bands, which in principle can have different masks.
                                                           !!! Pixels that are unseen in the main_band mask can be seen from other
                                                           !!! channels, so instead of applying the main_band mask to the N^-1 s
                                                           !!! result, I apply the specific masking to each step of the contraction.
                                                           >>> MULTIPLY BY MASK_CALIB_main_band AFTER CONTRACTION

9. 'comm_cgd_matmul_mod.f90', line 134: *> call multiply_by_sqrt_inv_N(eta)  !!! Why N^-1 signal and sqrt(N^-1) noise?

10. 'comm_cgd_precond_mod.f90', line 467: *> call get_noise_map(i)  !!! Useless function

11. See 'At_invN_A_sum' discussion in SAMPLE AMPLITUDES chapter

12. 'comm_chisq_mod.f90', line 280: *> residual = residual  !!! ??



##########################################################################################################################################
####################################**********************************************************############################################
####################################**************------------------------------**************############################################
####################################********-----------------MOD RECAP----------------********############################################
####################################**************------------------------------**************############################################
####################################**********************************************************############################################
##########################################################################################################################################

#####
##### Qualitative list of modifications module by module (skipping 'cleanup' routines)
#####

>> comm_beam_mod.f90:
        >> NEW GLOBAL VARIABLES: - real beams_fcn(:,:,:)
                                 - int numband
                                 - lgt freq_corr_noise
        >> NEW SUBROUTINES:
        >> MODDED SUBROUTINES:   - initialize_beam_mod: * Initializing 'numband' and 'freq_corr_noise'
                                                        * Collecting all bands' beams in 'beams_fcn'
                                 - multiply_with_beam: * If a 'band_id_in' is passed, the convolution is performed using the specific beam

>> comm_bp_mod.f90:
        >> NEW GLOBAL VARIABLES: - int numband
                                 - lgt freq_corr_noise
        >> NEW SUBROUTINES:
        >> MODDED SUBROUTINES:   - initialize_bp_mod: * Initializing 'numband' and 'freq_corr_noise'

>> comm_cgd_matmul_mod.f90:
        >> NEW GLOBAL VARIABLES:
        >> NEW SUBROUTINES:
        >> MODDED SUBROUTINES:   - compute_signal_rhs: * Generalizing 'map_sum = N^-1 residual + N^-1 rand' as 
                                                                      'map_sum = SUM_i [N(i)^-1 residuals(i)] + SUM_i [N(i)^-1 rand]'
                                 - compute_At_invN_A_x: * Generalizing 'map_sum = FT^-1[B alm]' as
                                                                       'map_sums(i) = FT^-1[B(i) alms(i)]'
                                                        * Generalizing 'map_sum += temp + fg' as
                                                                       'map_sums(i) += temps(i) + fgs(i)'
                                                        * Generalizing 'map_sum = N^-1 map_sum' as
                                                                       'map_sum = SUM_i [N(i)^-1 map_sums(i)]'

>> comm_cgd_precond_mod.f90:
        >> NEW GLOBAL VARIABLES:
        >> NEW SUBROUTINES
        >> MODDED SUBROUTINES:   - initialize_preconditioner: * Preconditioning is left with main band's invN_rms

>> comm_chisq_mod.f90:
        >> NEW GLOBAL VARIABLES:
        >> NEW SUBROUTINES:
        >> MODDED SUBROUTINES:   - compute_total_chisq: * Generalizing 'signal = FT^-1[B alm] * spec2data' as
                                                                       'signals(i) = FT^-1[B(i) alms(i)] * spec2datas(i)'
                                                        * Generalizing 'signal += fg' as
                                                                       'signals(i) += fgs(i)'
                                                        * Generalizing 'residual = cmbmap - signal' as
                                                                       'residuals(i) = cmbmaps(i) - signals(i)'
                                                        * Generalizing 'chisq = [sqrt(N)^-1 residual]^2' as
                                                                       'chisq = residual SUM_i [N(i)^-1 - residuals(i)]'
                                 - sample_gain: * Generalizing 'residual = cmbmap - temp - fg' as
                                                               'residuals(i) = cmbmaps(i) - temps(i) - fgs(i)'
                                                * Generalizing 'signal = FT^-1[B alm] * spec2data + fg' as
                                                               'signals(i) = FT^-1[B(i) alms(i)] * spec2datas(i) + fgs(i)'
                                                * Generalizing '1) signal *= mask_calib / bp' 
                                                               '2) residual *= mask_calib' as
                                                               '1) signals(i) *= mask_calibs(i) / bps(i)'
                                                               '2) residuals(i) *= mask_calibs(i)' 
                                                * Generalizing '1) sigma = signal [N^-1 signal * mask_calib]'
                                                               '2) mu = residual [N^-1 signal * mask_calib]' as
                                                               '1) sigma = signal SUM_i [N(i)^-1 signals(i) * mask_calibs(i)]'
                                                               '2) mu = residual SUM_i [N(i)^-1 signals(i) * mask_calibs(i)]'
                                 - sample_bandpass: * Minor lexical changes

>> comm_Cl_util_mod.f90:
        >> NEW GLOBAL VARIABLES: - int numband
                                 - lgt freq_corr_noise
        >> NEW SUBROUTINES:
        >> MODDED SUBROUTINES:   - initialize_Cl_util_mod: * Initializing 'numband' and 'freq_corr_noise'

>> comm_data_mod.f90:
        >> NEW GLOBAL VARIABLES: - real (private) reg_noises_fcn(:)
                                 - real cmbmaps_fcn(:,:,:)
                                 - real residuals_fcn(:,:,:)
                                 - real mask_calibs_fcn(:,:,:)
                                 - real fg_pix_spec_responses_fcn(:,:,:,:)
                                 - real fg_temps_fcn(:,:,:,:)
                                 - real inv_Ns_lowres_fcn(:,:,:,:)
                                 - real inv_Ns_scaled_fcn(:,:,:,:)
        >> NEW SUBROUTINES:
        >> MODDED SUBROUTINES:   - initialize_data_mod: * Collecting all bands' reg_noises in 'reg_noises_fcn'
                                                        * Generalizing 'temp_names = FG_TEMPLATE' as
                                                                       'temp_names(i) = FG_TEMPLATEs(i)'
                                                        * Collecting all bands' mask_calibs in 'mask_calibs_fcn'
                                                        * Generalizing 'temp initialization' as
                                                                       'all temps(i) initialization'
                                                        * Generalizing 'inv_N_lowres initialization' as
                                                                       'inv_Ns_lowres_fcn(i) initialization'
                                 - read_map_realization: * Generalizing 'cmbmap = reg_noise + rand' as
                                                                        'cmbmaps(i) = reg_noises(i) + rand' as
                                 - compute_residual: * Generalizing 'residual = cmbmap - temp - fg' as
                                                                    'residuals(i) = cmbmaps(i) - temps(i) - fgs(i)'
                                 - output_component_map: * Minor lexical changes
                                 - output_mixing_matrix: * Minor lexical changes
                                 - output_signal_correlations: * Minor lexical changes
                                 - output_ml_map_engine: * Generalizing 'Ft_invN_d = fg N^-1 residual' as
                                                                      'Ft_invN_d = fg SUM_i [N^-1 residual]'
                                                         * Generalizing 'Ft_invN_F = fg N^-1 fg' as
                                                                        'Ft_invN_F = fg SUM_i [N^-1 fgs(i)]'
                                                           >> also the N^-1 fg matrix - vector product is simplified using a 
                                                                       N(j)^-1 fg(j) vector - scalar product

>> comm_fg_component_mod.f90:
        >> NEW GLOBAL VARIABLES:
        >> NEW SUBROUTINES:
        >> MODDED SUBROUTINES:   - update_fg_pix_response_map: * Generalized to update all bands' spectral responses

>> comm_fg_mod.f90:
        >> NEW GLOBAL VARIABLES: - real (private) my_inv_Ns_fcn(:,:)
                                 - real (private) all_inv_Ns_fcn(:,:,:)
                                 - real (private) invN_regs_fcn(:,:,:)
        >> NEW SUBROUTINES:
        >> MODDED SUBROUTINES:   - sample_fg_pix_response_map: * Minor lexical changes
                                 - sample_spec_index_single_region: * Collecting all bands' reg_noises in 'invN_regs_fcn'
                                 - lnL_specind_ARS: * Generalizing 'lnL -= - 0.5 * f * N_reg^-1 * f' as
                                                                   'lnL -= - 0.5 * f * SUM_i [N_regs(i)^-1 * fs(i)]' 
                                                    * Generalizing 'lnL_jeffreys = log(sqrt(sum(df * N^-1 * df)))' as
                                                                   'lnL_jeffreys = log(sqrt(sum(df * SUM_i [N(i)^-1 * dfs(i)])))'
                                                      >> although these are useless lines of code
                                 - init_ind: * Initializing 'my_inv_Ns_fcn'
                                 - fg_init_chisq: * Generalizing 'chisq = SUM_i [(res(i)-s(i))**2 * N(i)^-1]' as
                                                                 'chisq = SUM_i {(res(i)-s(i)) * SUM_j [N(j)^-1 (res(j)-s(j))]}'
                                 - enforce_pos_amp: * Generalizing 'inv_N_local' to be non-diagonal
                                                    * Generalizing 'chisq = SUM_i [(res(i)-s(i))**2 * N(i)^-1]' as
                                                                   'chisq = SUM_i {(res(i)-s(i)) * SUM_j [N(j)^-1 (res(j)-s(j))]}'

>> comm_global_par_mod.f90:
        >> NEW GLOBAL VARIABLES:
        >> NEW SUBROUTINES:
        >> MODDED SUBROUTINES:   - sample_global_fg_par: * Minor lexical changes
                                 - optimize_priors: * Minor lexical changes

>> comm_mp_mod.f90:
        >> NEW GLOBAL VARIABLES:
        >> NEW SUBROUTINES:
        >> MODDED SUBROUTINES:   - sample_spectral_param_map: * Minor lexical changes
                                 - init_ind_by_nonlin_search: * Minor lexical changes
                                 - enforce_pos_amps: * Minor lexical changes

>> comm_N_mult_mod.f90:
        >> NEW GLOBAL VARIABLES: - int numband
                                 - lgt freq_corr_noise
        >> NEW SUBROUTINES:      - initialize_invN_rms_fcn: TAKES >> band_id_in = main band index
                                                            DOES * Initializes reg_noise, invN_rms and sqrt_invN_rms
                                 - initialize_invN_dense_fcn: TAKES >> band_id_in = main band index
                                                                    >> band_id_in2 = secondary band index
                                                              DOES * Initializes map_id_fcn to band_id_in2
                                                                   * Initializes invN_dense and sqrt_invN_dense
                                 - multiply_by_inv_N_column: TAKES >> map_in = map to be multiplied
                                                                   >> row = value position in the map, i.e. the pixel index
                                                                   >> stokes = stokes index
                                                                   >> N_format = noise format
                                                                   >> do_sqrt = if .true. multipies sqrt(N)^-1, else N^-1
                                                             DOES * If noise format is 'rms' multiplies the stokes/pix N^-1 
                                                                    value by map_in
                                                                  * If noise format is 'dense' does the following:
                                                                    >> applies ring2nest conversion if needed
                                                                    >> saves the only non-zero pixel in map_in into 'value'
                                                                    >> If one processor is involved multiplies the specific
                                                                       N^-1 column by value
                                                                    >> If two or more processors are involved exploits the
                                                                       pre-existing dgemv matrix - vector multiplication routine
                                                                    >> applies nest2ring conversion if needed
                                                                    >> rescales the vector by the relative band's noise amplitude
        >> MODDED SUBROUTINES:   - initialize_N_mult_mod: * If freq_corr_noise is .true., all the objects
                                                            are initialized on the main band. These objects are
                                                            >> reg_scale > reg_noise
                                                            >> invN_rms
                                                            >> sqrt_invN_rms
                                                            >> invN_dense
                                                            >> sqrt_invN_dense
                                 - get_noise_map: * Generalizing inv_N rescaling by the specific band's noise amplitude

>> commander.f90:
        >> NEW GLOBAL VARIABLES: - lgt freq_corr_noise
        >> NEW SUBROUTINES:
        >> MODDED SUBROUTINES:   - MAIN: * 'freq_corr_noise' is read from parameter file
                                         * all modules are initialized based on the noise correlation format
                                 - compute_single_chain: * Generalizing subroutine calls
                                                         * Generalizing 'inv_Ns_scaled_fcn' to every band
                                                         * Generalizing file output streams
                                 - output_pixel_to_file: * Generalizing the 'print-out-data' format in file writing




####
#### NEW PARAMETERS/FILES NEEDED IN THE 'parameter_file.txt'
####

FREQ_CORR_NOISE          = .true. # or .false.
if (FREQ_CORR_NOISE == .true.) then
> NOISE_RMS0101            = '..'..' # instead of standard NOISE_RMS01       > it's a .fits map
> INV_N_MAT0101            = '../..' # instead of standard INV_N_MAT01       > it's a .unf file
> SQRT_INV_N_MAT0101       = '../..' # instead of standard SQRT_INV_N_MAT01  > it's a .unf file





